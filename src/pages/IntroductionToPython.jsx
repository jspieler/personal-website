import React, { useEffect } from 'react';

import { CodeBlock, dracula } from 'react-code-blocks';

import { Article } from '../components/articles/Article';
import { ExternalLink } from '../components/articles/ExternalLink';
import { InlineCode } from '../components/articles/InlineCode';
import { LazyIframe } from '../components/articles/LazyIframe';

const IntroductionToPython = () => {
  return (
    <main className="main">
      <Article
        title={'Introduction To Python'}
        subtitle={'Yet Another Python Guide?'}
      >
        <p>
          The following introduction to Python serves as additional,
          supplementary material to the lecture of the same name.
          Since it is a comprehensive, stand-alone introduction, it
          can also be used to learn the basics of Python on your own.
          The concept of this introduction is inspired by the
          JavaScript reference in the{' '}
          <ExternalLink href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">
            MDN Web Docs
          </ExternalLink>{' '}
          which I really like because it provides good explanations
          along with code sandboxes that allow you to play directly
          with the code while learning. I would encourage you to do
          exactly that.
        </p>
        <p>The lecture slides are also available here.</p>
        <h3 id="what-is-python-and-why-you-should-learn-it">
          What Is Python and Why You Should Learn It
        </h3>
        <p>
          <ExternalLink href="https://www.python.org/">
            Python
          </ExternalLink>{' '}
          is a high-level programming language created by Guido van
          Rossum. It was released in 1991. Although images of snakes
          are often associated with Python, the name is actually
          derived from Guido van Rossum's favorite TV show, "Monty
          Python's Flying Circus". Python is an object-oriented
          programming language which is available on a wide variety of
          systems and can be used for a lot of different applications.
          The current version is Python 3, which will be the focus of
          the following explanations. Python is designed to be a
          beginner-friendly yet powerful programming language. In
          recent years, Python has gained increasing popularity,
          especially due to well-known and robust frameworks designed
          for scientific computing, artificial intelligence, and data
          science. Examples of such frameworks include{' '}
          <ExternalLink href="https://numpy.org/">Numpy</ExternalLink>
          ,{' '}
          <ExternalLink href="https://pandas.pydata.org/">
            Pandas
          </ExternalLink>
          ,{' '}
          <ExternalLink href="https://pytorch.org/">
            PyTorch
          </ExternalLink>{' '}
          or{' '}
          <ExternalLink href="https://www.tensorflow.org/">
            TensorFlow
          </ExternalLink>
          . Python is also commonly used for automation, prototyping,
          and even web development.
        </p>
        <p>
          Unlike many other programming languages, Python statements
          do not require termination with a special character. The
          Python interpreter identifies the end of a statement through
          the presence of a newline, generated by pressing the
          "Return" key on the keyboard. We will delve into multi-line
          statements in subsequent sections. Another crucial point to
          note is that Python relies on indentation instead of
          delimiters like curly braces. While the specific amount of
          indentation doesn't hold significance, it must remain
          consistent within a given depth of a loop or conditional
          statement. Additionally, statements that are not intended to
          be indented must start from the first column. However,
          adhering to the convention outlined in{' '}
          <ExternalLink href="https://peps.python.org/pep-0008/">
            PEP 8
          </ExternalLink>
          , it is recommended to use 4 spaces for indentation, a
          practice we'll explore further in upcoming discussions.
        </p>

        <h3 id="how-to-invoke-python-code">
          How To Invoke Python Code
        </h3>
        <p>
          To get started with running Python code on your computer,
          you'll need to install a{' '}
          <ExternalLink href="https://www.python.org/downloads/">
            Python interpreter
          </ExternalLink>{' '}
          which is available for Windows, Linux and Mac OS.
          Alternatively, you can also use{' '}
          <ExternalLink href="https://docs.conda.io/en/latest/">
            Conda
          </ExternalLink>{' '}
          (or one of its variations like MicroConda or Mamba). We'll
          talk more about these options when we discuss virtual
          environments in a moment.
        </p>
        <p>
          Once Python is installed on your system, there are two main
          ways to start using it. The first method is by opening your
          shell or command prompt and typing "python". This will
          launch the Python interpreter, and you'll see something like
          this:
          <CodeBlock
            text={`Python 3.11.3 (main, Jun  5 2023, 09:32:32) [GCC 13.1.1 20230429] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>>`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          The three greater-than signs (&gt;&gt;&gt;) are prompts that
          indicate you can type your commands below them. When you
          press "Enter", Python will execute your command. If you type
          a command like Python's <InlineCode>print()</InlineCode>,
          the result will show up on the screen, like this:
          <CodeBlock
            text={`>>> print("Hello World")\nHello World`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          For longer programs, you can use your preferred text editor
          or Integrated Development Environment (IDE) to write your
          Python code. The common file extension for Python files is
          ".py". To run your program, type "python" followed by the
          name or path of your file. Most modern IDEs also offer a
          "run" button that you can click.
        </p>
        <p>
          One of the great advantages of Python is its easy-to-use
          libraries and external packages. Since many people use
          Python, there's a wide variety of pre-built packages
          available for many different tasks. The Python Package Index
          (<ExternalLink href="https://pypi.org/">PyPI</ExternalLink>)
          is a collection of software for Python that offers numerous
          packages. You can install Python packages from PyPI using a
          package management tool called "pip".
        </p>
        <div>
          However, Python is not great at dependency management. This
          is why nearly every Python user recommends to use virtual
          environments. Virtual environments are a Python tool for
          dependency management and project isolation. They provide a
          simple solution for a lot of potential problems by helping
          you to:
          <div>
            <ul>
              <li>Resolve dependency issues</li>
              <li>Create self-contained and reproducible projects</li>
              <li>Avoid system pollution</li>
              <li>Install packages without admin rights</li>
            </ul>
          </div>
          There are various approaches to creating a virtual
          environment. One option is to use{' '}
          <ExternalLink href="https://docs.python.org/3/library/venv.html">
            venv
          </ExternalLink>
          , a built-in tool in Python. External tools like virtualenv
          or Conda are also commonly used. Conda provides an
          alternative package and environment management approach. It
          not only enables easy creation of virtual environments with
          different Python versions but also introduces an additional
          feature set. It's worth noting that Conda is a separate
          project and is unrelated to pip. It uses an alternative
          package index maintained by the Anaconda project instead of
          PyPI. Conda packages can be installed using the command
          "conda install". As an alternative,{' '}
          <ExternalLink href="https://www.docker.com/">
            Docker
          </ExternalLink>{' '}
          can also be used to create a containerized Python
          development environment. Docker allows you to package your
          Python application along with its dependencies and system
          configurations, ensuring consistency across different
          environments.
        </div>

        <h3 id="variables">Variables</h3>
        <p>
          <LazyIframe src="https://trinket.io/embed/python/3d8d7ce66b" />
        </p>

        <h3 id="data-types">Data Types</h3>
        <p>...</p>

        <h3 id="control-structures">Control Structures</h3>
        <h4>Conditions</h4>
        <p>
          In Python, control structures like the{' '}
          <InlineCode>if</InlineCode> statement, along with optional{' '}
          <InlineCode>elif</InlineCode> and{' '}
          <InlineCode>else</InlineCode> statements, are the foundation
          for executing conditional logic in your programs. The{' '}
          <InlineCode>if</InlineCode>
          statement evaluates the expression following it. If the
          expression is true, Python executes the statement(s) that
          follow. If the expression is false, Python continues with
          the <InlineCode>elif</InlineCode> statement (if there is
          one), and tests that expression. It proceeds to test the
          expressions associated with any{' '}
          <InlineCode>elif</InlineCode> statements in order, executing
          the first set of statements for which the expression is
          true. If none of the <InlineCode>elif</InlineCode>{' '}
          expressions are true, and there is an{' '}
          <InlineCode>else</InlineCode> statement, Python executes the
          statement(s) associated with the{' '}
          <InlineCode>else</InlineCode>. If there's no{' '}
          <InlineCode>else</InlineCode> statement, Python simply moves
          on to the statements following the{' '}
          <InlineCode>if</InlineCode> block. It's important to note
          that once Python encounters a true expression associated
          with an <InlineCode>if</InlineCode> or{' '}
          <InlineCode>elif</InlineCode> statement, it executes the
          corresponding statement(s) and doesn't evaluate any other
          expressions that follow.
        </p>
        <h4>Loops</h4>
        <p>
          Python provides two primary types of loops: the{' '}
          <InlineCode>for</InlineCode> loop and the{' '}
          <InlineCode>while</InlineCode> loop.
        </p>
        <p>
          Python, like other programming languages, provides a{' '}
          <InlineCode>for</InlineCode> loop which allows you to
          iterate. Although, the <InlineCode>for</InlineCode> loop is
          very useful, there is a more "pythonic" and powerful way for
          iteration in Python. The <InlineCode>for in</InlineCode>{' '}
          loop allows you to iterate over all the values in a sequence
          (e.g. string, list or tuple), performing the same task in
          each element. If the elements of the sequence being iterated
          over contain tuples or lists, a comma separated list can be
          used to unpack each individual element of the sequence. If
          you need an index, you can use{' '}
          <InlineCode>enumerate</InlineCode>.
        </p>
        <p>
          The <InlineCode>for</InlineCode> loop provides a great way
          to process the elements of a sequence. However, sometimes it
          is necessary to do some repetitive computation which is not
          based on an array. In those cases, the{' '}
          <InlineCode>while</InlineCode> loop can be used. When Python
          encounters a <InlineCode>while</InlineCode> loop, it firsts
          tests the expression provided. If the expression is false
          and there's an <InlineCode>else</InlineCode> clause, Python
          executes the statements following the{' '}
          <InlineCode>else</InlineCode>. Without an{' '}
          <InlineCode>else</InlineCode> clause, if the expression is
          false, control moves to the first statement after the{' '}
          <InlineCode>while</InlineCode> loop. If the expression is
          true, Python executes the statements following the{' '}
          <InlineCode>while</InlineCode> statement. Once those
          statements are completed, the expression is tested again,
          and the process repeats. As long as the expression remains
          true, Python continues executing the statements after the
          <InlineCode>while</InlineCode>. When the expression becomes
          false, the statements after the{' '}
          <InlineCode>else</InlineCode> (if present) are executed.
        </p>
        <p>
          It's worth mentioning that Python programmers often use{' '}
          <InlineCode>while</InlineCode> loops in a somewhat
          unconventional way. They may create "infinite" loops and
          control when to exit the loop with statements inside the
          loop. To exit a loop (<InlineCode>for</InlineCode> or{' '}
          <InlineCode>while</InlineCode>) prematurely, you can use the{' '}
          <InlineCode>break</InlineCode> statement. The{' '}
          <InlineCode>continue</InlineCode> statement, on the other
          hand, is used to skip the remaining part of the current
          iteration and move on to the next one. In a{' '}
          <InlineCode>for</InlineCode> loop, the loop variable's value
          is automatically incremented after a{' '}
          <InlineCode>continue</InlineCode> statement, so the next
          iteration proceeds as usual.
        </p>

        <h3 id="data-structures">Data Structures</h3>
        <p>...</p>

        <h4>Lists</h4>
        <p>
          Lists serve as a fundamental tool in Python for holding
          collections of objects that are indexed using numerical
          positions. These objects within a list can span various
          types, including numbers, strings, functions, user-defined
          objects, and even other lists. This versatility enables the
          creation of complex data structures with ease. To define a
          list in Python, enclose a sequence of elements you want
          within square brackets, separated by commas. To initialize
          an empty list, simply use square brackets without any
          elements inside. Notably, the items in a list can have
          different data types. Accessing individual elements within a
          list is achieved by employing square brackets after the
          list's name, specifying the index of the desired element.
          It's important to remember that Python employs zero-based
          indexing, meaning the first element corresponds to index 0.
          In the case of nested lists (lists within lists), you can
          utilize additional sets of square brackets to access
          individual elements. To get the number of elements within a
          list, Python offers the built-in{' '}
          <InlineCode>len()</InlineCode> function.
          <LazyIframe src="https://trinket.io/embed/python/179b14e949" />
        </p>
        <h5>List Indexing and Slicing</h5>
        <p>
          The slicing operations introduced in the section about
          strings are equally applicable to lists, with a particularly
          useful extension. In addition to utilizing slicing to
          extract a section of a list, you can employ slicing to
          assign values to elements within a list, indicated by a
          slice positioned on the left side of an equal sign. This
          distinction arises from the fact that lists are mutable
          objects, while strings are immutable. When assigning values
          using this approach, if the count of elements in the list on
          the right side of the assignment doesn't match the number of
          elements suggested by the slice's subscript, the list will
          automatically adjust its size to accommodate the assignment.
          Conversely, assignments performed via a single subscript
          will consistently maintain the list's length. Slices further
          offer the capability to remove elements from a list.
          Alternatively, the <InlineCode>del</InlineCode> statement
          can be employed to remove items from a list. To use the{' '}
          <InlineCode>del</InlineCode> statement, specify the element
          or slice of the list that requires deletion. Another
          important use of slices is to make a separate modifiable
          copy of a list. We will discuss later why this is important.
          In this case, a slice is created without a starting and
          ending index.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1c6c2fe35d" />
        <h5>List Operators</h5>
        <h6>Concatenation</h6>
        <p>
          To merge the contents of two lists, the plus sign is used to
          concatenate them. The outcome is a unified list whose length
          equals the sum of both original lists' lengths. This new
          list contains all the elements from the first list followed
          by all the elements from the second list. List concatenation
          only works when combining two lists. To add a scalar to the
          end of a list, you either need to surround the scalar with
          square brackets or use the <InlineCode>append()</InlineCode>{' '}
          method.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ef8c8f064f" />
        <h6>Repetition</h6>
        <p>
          As for strings, the asterisk is overloaded for lists to
          serve as a repetition operator, Applying repetition to a
          list results in a single list with the elements of the
          original list repeated as many times as specified. A list
          consisting other lists can be created by surrounding a list
          to be repeated with an extra set of square brackets.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/74423edc47" />
        <h6>
          The <InlineCode>in</InlineCode> Operator
        </h6>
        <p>
          The <InlineCode>in</InlineCode> operator provides an
          extremely convenient technique for determining whether a
          specific value resides within a list. These evaluations are
          structured by positioning a value on the left side of the
          operator and a list on the right side. The outcome is either{' '}
          <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode>, rendering it highly suitable
          for conditional statements. It's important to exercise
          caution when constructing expressions employing the{' '}
          <InlineCode>in</InlineCode> operator, as an exact match in
          both type and value is necessary for a{' '}
          <InlineCode>True</InlineCode> result. Moreover, the{' '}
          <InlineCode>in</InlineCode> operator works seamlessly with
          expressions that evaluate to elements within a list.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/be273e1259" />
        <h6>List Comprehension</h6>
        <p>
          List comprehensions are a concise and elegant way to create
          lists in Python. They allow you to generate a new list by
          applying an expression to each item in an existing iterable
          (like a list, tuple, or range) and optionally applying a
          condition to filter the items. List comprehensions not only
          make your code more compact, but they also enhance its
          readability by encapsulating complex operations in a
          comprehensible format.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/684e868e0f" />
        <h6>Functions and Methods for Lists</h6>
        <p>
          We already learnt that the <InlineCode>len()</InlineCode>{' '}
          function will return the number of elements in a list. But
          there are more built-in functions and methods for lists in
          Python. For a single list input, the{' '}
          <InlineCode>min()</InlineCode> function extracts the
          smallest element from the list, while the{' '}
          <InlineCode>max()</InlineCode> function retrieves the
          largest. To append a single element at the end of a list,
          the <InlineCode>append()</InlineCode> method can be used. If
          you need to add several elements to the end of a list,
          either the concatenation operator or the{' '}
          <InlineCode>extend()</InlineCode>method can be employed. If
          your intent is to insert an element at a position other than
          the end of the list, the <InlineCode>insert()</InlineCode>{' '}
          method proves useful. This method demands two arguments: the
          index for the insertion location and the item itself.
          Notably, a single element can be inserted using{' '}
          <InlineCode>insert()</InlineCode>, while for multiple
          insertions, slicing can be utilized. When the objective
          involves eliminating an item from a list based on its value,
          the <InlineCode>remove()</InlineCode> method proves
          invaluable. It removes only the initial occurrence of the
          value within the list. Both the{' '}
          <InlineCode>reverse()</InlineCode> and{' '}
          <InlineCode>sort()</InlineCode> methods operate in place,
          meaning they change the original order of elements within
          the list. If preservation of the initial order is essential,
          it's advisable to generate a copy of the list. By default,
          the <InlineCode>sort()</InlineCode> method sorts its numeric
          arguments in numerical order and string arguments in
          alphabetical order. Recall that lists can contain arbitrary
          objects, so <InlineCode>sort()</InlineCode> needs to be very
          flexible. In general, it sorts scalar numeric values before
          scalar string values and lists by first comparing their
          initial elements and continuing through the available list
          elements until one list differs from the other. The{' '}
          <InlineCode>count()</InlineCode> method accepts a single
          argument representing the value to be located and calculates
          the frequency of that value within the list. On the other
          hand, the <InlineCode>index()</InlineCode> method offers the
          index (subscript) of the first occurrence of a specified
          value.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/697878d467" />

        <h4>Tuples</h4>
        <p>
          Tuples, like lists, are a fundamental data structure in
          Python, used to store collections of items. They can contain
          elements of various data types, including numbers, strings,
          and even other tuples. Tuples are similar to lists but there
          is one important difference, namely that tuples are not
          mutable. This means that once a tuple is created, its
          elements can't be modified in place. The immutability of
          tuples makes them valuable in scenarios where you want to
          ensure that the data remains constant throughout the
          program's execution. Tuples are constructed by enclosing
          their values within parentheses. When a tuple is not
          embedded within an expression, the parentheses may be
          omitted. To create an empty tuple, simply utilize a pair of
          empty parentheses. However, due to the use of parentheses
          for grouping in arithmetic expressions, it is essential to
          include a comma after the sole element to explicitly denote
          a tuple with only one element in an assignment statement.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9e85dc5f9b" />
        <h5>Operators and Indexing for Tuples</h5>
        <p>
          The same operators as mentioned in the previous section for
          lists apply to tuples. Keep in mind that tuples are
          immutable. Thus, slicing operations for tuples are more
          similar to strings than lists. Slicing can be used to
          extract parts of a tuple, but not to change it.
        </p>
        <h5>Functions and Methods for Tuples</h5>
        <p>
          There are no methods for tuples. However, tuples and list
          can be easily converted to each other using the built-in
          function <InlineCode>list</InlineCode> and{' '}
          <InlineCode>tuple</InlineCode>.
        </p>

        <h4>Dictionaries</h4>
        <p>
          Dictionaries in Python share similarities with lists, as
          they can store arbitrary objects and be nested to any
          desired depth. However, unlike lists, dictionaries are
          indexed by keys, which can be any immutable object, such as
          strings or tuples. Let's delve into this concept with a
          straightforward example: imagine a scenario where we want to
          store student matriculation numbers as tuples inside a list,
          where the first tuple element represents the student's name,
          and the second element is their matriculation number.
          However, if we wish to retrieve the matriculation number of
          a specific student, we'd need to search through each element
          in the list to find the tuple with the student's name as the
          first element before we can access the desired number. With
          a dictionary, we can use the student's name as the index,
          often referred to as a key. This significantly simplifies
          the process of retrieving the information we need:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/2f654ae385" />
        <p>
          As the example above illustrates, a dictionary can be
          initialized using a comma-separated list of key/value pairs
          enclosed in curly braces. An empty dictionary can be created
          with a pair of empty curly braces. It's important to note
          that dictionary keys are not limited to strings, and they
          don't need to be of the same data type. However, it's
          crucial to remember that mutable objects, such as lists,
          cannot be used as dictionary keys. You can add key/value
          pairs to a dictionary using assignment statements, and if
          you need to remove a specific key/value pair from a
          dictionary, you can use the <InlineCode>del</InlineCode>{' '}
          statement for this purpose.
        </p>
        <h5>Functions and Methods for Dictionaries</h5>
        <p>TODO</p>

        <h4>Sets</h4>
        <p>
          Python's built-in set type is similar to dictionaries. Sets
          are unordered and its elements are unique. A set itself can
          be modified, but the elements in the set must be immutable.
          There are two ways to create a set in Python: first, you can
          create a set using the built-in{' '}
          <InlineCode>set()</InlineCode> function or alternately, a
          set can be defined using curly braces. To define an empty
          set, the <InlineCode>set()</InlineCode> function needs to be
          used. Recall that Python interprets empty curly braces as an
          empty dictionary. The elements in a set can be objects of
          different types. However, keep in mind that set elements
          must be immutable. Thus, a tuple may be included in a set,
          but lists and dictionaries are mutable, so they can't be set
          elements.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/3f3742ad5d" />
        <h5>Functions and Methods for Sets</h5>
        <p>
          As for lists, the <InlineCode>len()</InlineCode> function
          can be used to get the number of elements in a set and the{' '}
          <InlineCode>in</InlineCode> and{' '}
          <InlineCode>not in</InlineCode> operators can be used to
          test for membership. However, many of the operations that
          can be used for Python's other data types, don't make sense
          for sets. For example, sets can't be indexed or sliced.
          Nevertheless, Python provides a bunch of operation on set
          objects which are similar to the operations defined for
          mathematical sets. Set union of two or more sets can be
          performed with the "|" operator or with the{' '}
          <InlineCode>union()</InlineCode> method. The resulting set
          contains all elements that are present in any of the
          specified sets. To compute the intersection of two or more
          sets , i.e. return a set containing only elements that are
          present in all of the specified sets, the "&" operator or{' '}
          <InlineCode>intersection()</InlineCode> method can be used.
          The difference between two or more sets can be computed
          using the "-" operator or the{' '}
          <InlineCode>difference()</InlineCode> method. For two sets,
          this will return a set containing all elements that are in
          the first set, but not in the second set. When multiple sets
          are specified, the operation is performed from left to
          right. There are many more operations available such as{' '}
          <InlineCode>update()</InlineCode> for updating a set,{' '}
          <InlineCode>add()</InlineCode> to add an element to a set,{' '}
          <InlineCode>remove()</InlineCode> to remove an element from
          a set and <InlineCode>clear()</InlineCode> to remove all
          elements from a set. For more details, refer to the{' '}
          <ExternalLink href="https://docs.python.org/3.11/library/stdtypes.html#set">
            Python documentation
          </ExternalLink>{' '}
          .There's also another built-in type in Python called{' '}
          <InlineCode>frozenset</InlineCode> which is exactly the same
          as set, but is immutable.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ab8ea2aa12" />

        <h3 id="functions-and-modules">Functions and Modules</h3>

        <h4>Functions</h4>
        {/* TODO: Sandbox examples */}
        <p>
          Functions are a fundamental component of any programming
          language for two primary reasons. First, they enable code
          reusability, eliminating the need to duplicate and modify
          code each time it's used. Second, functions allow you to
          logically isolate various sub-tasks that inevitably arise
          when working on a program. This programming approach is
          known as modular programming and is generally considered a
          best practice for writing readable and maintainable code.
        </p>
        <p>
          In Python, functions are treated as objects. As a result,
          they can be assigned to variables, stored in lists or
          tuples, passed as arguments to other functions, and more.
          However, functions possess a unique property that
          distinguishes them from other Python objects: they can
          accept a list of arguments enclosed in parentheses and
          optionally return a value. You may already be familiar with
          some of Python's built-in functions, such as{' '}
          <InlineCode>len()</InlineCode>, and you've encountered
          methods, which are similar to functions and defined in a
          similar manner. In this section, we will delve into various
          aspects of functions, including how to create and import
          them into your programs.
        </p>
        <h5>Variable Scoping</h5>
        <p>
          In Python, you can typically reference variables anywhere in
          your program. However, when you define a function, Python
          creates a distinct namespace within that function. A
          namespace serves as a mapping between object names in your
          program and their corresponding memory locations where
          Python stores their values. Consequently, when a variable is
          created inside a function, Python recognizes it as a local
          variable within that function's namespace, distinct from
          variables with the same name defined elsewhere in the
          program. You can also reference a variable inside a function
          that already exists in your program at the time the function
          is called. Additionally, you can declare global variables
          using the <InlineCode>global</InlineCode> statement, though
          this should be only used for situations where no other
          reasonable solution is available. Consequently, we won't
          delve into global variables in detail here. When Python
          attempts to resolve the reference of a name in your program,
          names within a function's local namespace take precedence,
          followed by names of global objects or objects imported into
          the global namespace from a module. Finally, built-in object
          names are searched as a last resort. Due to this search
          order, Python's scoping is sometimes referred to as
          following the LGB rule.
        </p>
        <h5>Function Basics</h5>
        <p>
          In Python, functions are defined using the{' '}
          <InlineCode>def</InlineCode> statement. The function's name
          follows the <InlineCode>def</InlineCode> keyword, followed
          by a parenthesized list of arguments to be passed to the
          function. If a function does not require any arguments, an
          empty set of parentheses is used. A colon (:) comes after
          the parenthesized list. On the next line, an indented
          triple-quoted string, known as a docstring, provides
          documentation about the function. While not strictly
          necessary, docstrings are good practice. The function body
          follows the <InlineCode>def</InlineCode> line and the
          optional docstring. The function returns control to the
          calling environment when it encounters a{' '}
          <InlineCode>return</InlineCode> statement or when it reaches
          the end of the function body. If the function lacks a{' '}
          <InlineCode>return</InlineCode> statement, calling it will
          return the value <InlineCode>None</InlineCode>. To call a
          function, you refer to its name followed by a parenthesized
          list of arguments. For functions with no arguments, you
          simply use empty parentheses.
        </p>
        <h5>Name Arguments and Default Values</h5>
        <p>
          When passing arguments to a function without specifying
          their names, Python assumes that you've arranged the
          arguments in the order they were defined in the function. To
          mitigate the need to remember argument order, Python allows
          you to use named arguments. When calling a function, you can
          precede some or all of the arguments with a name and an
          equal sign, making it clear which argument corresponds to
          which parameter in the function. For added flexibility, when
          defining a function, Python allows you to specify default
          values for some or all of the arguments, making it optional
          for users to provide these arguments. To set a default value
          when defining a function, use a syntax similar to naming
          arguments when calling a function, appending an equal sign
          followed by the desired default value. When combining named
          and unnamed arguments in a function call, unnamed arguments
          must precede named ones in the argument list. Thus, place
          required arguments before optional ones in the function's
          argument list.
        </p>
        <h5>Variable Number of Arguments</h5>
        <p>
          In some cases, it's impossible to predict in advance how
          many arguments a function will receive. By designating a
          function argument with a name beginning with an asterisk,
          Python will collect all unnamed arguments passed to the
          function into a tuple, which can be accessed using that
          argument's name. A similar technique can be employed to
          create functions that can handle an unlimited number of
          keyword-argument pairs. If an argument in a function is
          prefixed with two asterisks, Python will collect all
          keyword-argument pairs that were not explicitly declared as
          arguments into a dictionary. This argument must be the last
          one in the function definition. This approach enables you to
          write a function that accepts any named parameter, even if
          you don't know the parameter name when writing the function.
        </p>
        <h5>Functional Programming and Anonymous Functions</h5>
        <p>
          When you need to perform the same operation on a list of
          objects, an alternative to using a{' '}
          <InlineCode>for</InlineCode> loop is the{' '}
          <InlineCode>map</InlineCode> function. This function accepts
          another function as its first argument and one or more lists
          as additional arguments. The number of provided lists must
          match the number of arguments expected by the mapped
          function. Python offers the <InlineCode>lambda</InlineCode>{' '}
          operator for creating anonymous functions when you only need
          a function once. Anonymous functions are limited to a single
          statement, which becomes the value returned by the{' '}
          <InlineCode>lambda</InlineCode> operator. Instead of
          enclosing the arguments in parentheses, you list them after
          the <InlineCode>lambda</InlineCode> keyword, separated by
          commas.
        </p>
        <p>
          Another functional programming tool in Python is the{' '}
          <InlineCode>filter</InlineCode> function. Like{' '}
          <InlineCode>map</InlineCode>, it takes a function as its
          first argument and a list as its second argument. However,{' '}
          <InlineCode>filter</InlineCode> returns a new list
          containing only those elements for which the function
          returns <InlineCode>True</InlineCode>. You might also recall
          list comprehensions as an alternative way to apply an
          expression to all elements of a list. In fact, a list
          comprehension with a single <InlineCode>for</InlineCode>{' '}
          clause is similar to a call to <InlineCode>map</InlineCode>.
          By adding an <InlineCode>if</InlineCode> clause to the
          comprehension, it becomes similar to embedding a call to{' '}
          <InlineCode>filter</InlineCode> within a{' '}
          <InlineCode>map</InlineCode>.
        </p>
        <p>
          Finally, the <InlineCode>reduce</InlineCode> function takes
          a function with exactly two arguments as its first argument
          and a list as its second argument. It successively applies
          the function to the list's elements, using the current
          result as the first argument and an element from the list as
          the second argument. <InlineCode>reduce</InlineCode> returns
          a scalar value. Optionally, you can provide a third argument
          as a starting value, which defaults to 0.
        </p>

        <h4>Modules</h4>
        <p>
          Python's core design philosophy emphasizes simplicity and
          efficiency, keeping the language small and easy to learn.
          However, many programming tasks require additional
          capabilities, which are provided through the use of modules.
          In Python, a module is a collection of code that groups
          together functions, classes, and variables according to
          functionality. Modules serve as a way to organize your code
          into reusable and logically grouped components. They are
          essential for managing complexity in larger programs and
          promoting code reuse across projects. Python comes with an
          extensive standard library of modules that provide pre-built
          functionality for various tasks. We will explore some of the
          most commonly used standard modules distributed with Python
          later on. In addition to the standard modules, there are
          many additional packages available for installation, such as
          those from PyPi or Conda. However, exercise caution when
          installing third-party packages to ensure their
          trustworthiness and compatibility with your project.
        </p>
        <p>
          To create a module, you simply save your Python code in a
          separate <InlineCode>.py</InlineCode> file with a
          descriptive name, such as{' '}
          <InlineCode>my_module.py</InlineCode>. This file should
          contain functions, classes, or variables that you want to
          reuse in other parts of your program or in other programs.
          As discussed earlier in the context of variable scoping,
          Python identifies which variable or function you are
          referring to by resolving its name in a namespace. To use
          functions, classes, or variables from a module in your
          Python program, you need to import the module. Python
          provides three ways to do this. The simplest way to access a
          module is to provide the module's name to the{' '}
          <InlineCode>import</InlineCode> statement. For example, to
          import a module named <InlineCode>my_module</InlineCode>,
          you'd use <InlineCode>import my_module</InlineCode>. It
          makes all the functions, classes, and variables in the
          module available under the{' '}
          <InlineCode>my_module</InlineCode> namespace. If you only
          need specific items from a module, you can import them
          directly. This way, you can use{' '}
          <InlineCode>function_name</InlineCode> without needing to
          prefix it with <InlineCode>module_name</InlineCode>. For
          instance,{' '}
          <InlineCode>from my_module import my_function</InlineCode>.
          While this approach is slightly more efficient than
          importing an entire module, it eliminates the explicit
          connection between the imported function and the module it
          was imported from. You also need to list every function you
          want to use in the import statement. You can also import all
          of the objects from a module into the local namespace by
          using an asterisk after the <InlineCode>import</InlineCode>{' '}
          statement, e.g.{' '}
          <InlineCode>from my_module import *</InlineCode>. Since this
          may override existing objects and even built-in objects,
          imports of whole modules should be used carefully. To give a
          module a shorter name, you can use the{' '}
          <InlineCode>as</InlineCode> keyword to create an alias. This
          is useful when working with modules with long names or to
          avoid naming conflicts. For example,{' '}
          <InlineCode>import my_long_module_name as mlm</InlineCode>.
        </p>
        <p>
          When you import a module, Python searches for it in a
          specific order. First, it checks the current directory where
          your script is located. Then, it looks in the built-in
          modules. Finally, it searches in directories listed in the
          <InlineCode>sys.path</InlineCode> variable. Understanding
          this order can help you manage your module imports
          effectively.
        </p>
      </Article>
    </main>
  );
};

export { IntroductionToPython };
