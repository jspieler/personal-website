import React from 'react';

import { CodeBlock, dracula } from 'react-code-blocks';

import { Article } from '../components/articles/Article';
import { ExternalLink } from '../components/articles/ExternalLink';
import { InlineCode } from '../components/articles/InlineCode';
import { LazyIframe } from '../components/articles/LazyIframe';
import { Table } from '../components/articles/Table';

const IntroductionToPython = () => {
  return (
    <main className="main">
      <Article
        title={'Introduction To Python'}
        subtitle={'Yet Another Python Guide?'}
      >
        <p>
          The following introduction to Python serves as additional,
          supplementary material to the lecture of the same name.
          Since it is a comprehensive, stand-alone introduction, it
          can also be used to learn the basics of Python on your own.
          The concept of this introduction is inspired by the
          JavaScript reference in the{' '}
          <ExternalLink href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">
            MDN Web Docs
          </ExternalLink>{' '}
          which I really like because it provides good explanations
          along with code sandboxes that allow you to play directly
          with the code while learning. I would encourage you to do
          exactly that.
        </p>
        <p>
          Please be aware that certain code examples have been
          adjusted due to limitations in{' '}
          <ExternalLink href="https://trinket.io/">
            Trinket.io
          </ExternalLink>
          . Some functionalities, such as f-strings, may not be
          available or fully supported. Additionally, there may be
          missing examples for certain standard library modules that
          cannot be utilized within the Trinket environment at this
          time.
        </p>
        <p>The lecture slides are also available here.</p>
        <h3 id="what-is-python-and-why-you-should-learn-it">
          What Is Python and Why You Should Learn It
        </h3>
        <p>
          <ExternalLink href="https://www.python.org/">
            Python
          </ExternalLink>{' '}
          is a high-level programming language created by Guido van
          Rossum. It was released in 1991. Although images of snakes
          are often associated with Python, the name is actually
          derived from Guido van Rossum's favorite TV show, "Monty
          Python's Flying Circus". Python is an object-oriented
          programming language which is available on a wide variety of
          systems and can be used for a lot of different applications.
          The current version is Python 3, which will be the focus of
          the following explanations. Python is designed to be a
          beginner-friendly yet powerful programming language. In
          recent years, Python has gained increasing popularity,
          especially due to well-known and powerful frameworks
          designed for scientific computing, artificial intelligence,
          and data science. Examples of such frameworks include{' '}
          <ExternalLink href="https://numpy.org/">Numpy</ExternalLink>
          ,{' '}
          <ExternalLink href="https://pandas.pydata.org/">
            Pandas
          </ExternalLink>
          ,{' '}
          <ExternalLink href="https://pytorch.org/">
            PyTorch
          </ExternalLink>{' '}
          or{' '}
          <ExternalLink href="https://www.tensorflow.org/">
            TensorFlow
          </ExternalLink>
          . Python is also commonly used for automation, prototyping,
          and even web development.
        </p>
        <p>
          Unlike many other programming languages, Python statements
          do not require termination with a special character. The
          Python interpreter identifies the end of a statement through
          the presence of a newline, generated by pressing the
          "Return" key on the keyboard. We will delve into multi-line
          statements in subsequent sections. Another crucial point to
          note is that Python relies on indentation instead of
          delimiters like curly braces. While the specific amount of
          indentation doesn't hold significance, it must remain
          consistent within a given depth of a loop or conditional
          statement. Additionally, statements that are not intended to
          be indented must start from the first column. However,
          adhering to the convention outlined in{' '}
          <ExternalLink href="https://peps.python.org/pep-0008/">
            PEP 8
          </ExternalLink>
          , it is recommended to use 4 spaces for indentation, a
          practice we'll explore further in upcoming discussions.
        </p>
        <p>
          Now, you might be wondering, what are PEPs?{' '}
          <ExternalLink href="https://peps.python.org/)">
            PEP
          </ExternalLink>{' '}
          stands for Python Enhancement Proposal. These are documents
          that outline design decisions, standards, and guidelines for
          the Python programming language. While compliance with most
          PEPs is voluntary, they are considered best practice in the
          Python community. For example, PEP 257 provides guidelines
          for docstring conventions, which are essential for
          documenting Python code effectively. However, there are some
          PEPs that are mandatory and must be followed. One such
          example is PEP 8, which is the Python Enhancement Proposal
          for the style guide of Python code. It provides
          recommendations on how to format your code for clarity and
          consistency.
        </p>
        <h3 id="how-to-invoke-python-code">
          How To Invoke Python Code
        </h3>
        <p>
          To get started with running Python code on your computer,
          you'll need to install a{' '}
          <ExternalLink href="https://www.python.org/downloads/">
            Python interpreter
          </ExternalLink>{' '}
          which is available for Windows, Linux and Mac OS.
          Alternatively, you can also use{' '}
          <ExternalLink href="https://docs.conda.io/en/latest/">
            Conda
          </ExternalLink>{' '}
          (or one of its variants like MiniConda or Mamba). We'll talk
          more about these options when we discuss virtual
          environments in a moment.
        </p>
        <p>
          Once Python is installed on your system, there are two main
          ways to start using it. The first method is by opening your
          shell or command prompt and typing "python". This will
          launch the Python interpreter, and you'll see something like
          this:
          <CodeBlock
            text={`Python 3.11.3 (main, Jun  5 2023, 09:32:32) [GCC 13.1.1 20230429] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>>`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          The three greater-than signs (&gt;&gt;&gt;) are prompts that
          indicate you can type your commands after them. When you
          press "Enter", Python will execute your command. If you type
          a command like Python's <InlineCode>print()</InlineCode>,
          the result will show up on the screen, like this:
          <CodeBlock
            text={`>>> print("Hello World")\nHello World`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          For longer programs, you can use your preferred text editor
          or Integrated Development Environment (IDE) to write your
          Python code. The common file extension for Python files is
          ".py". To run your program, type "python" followed by the
          name or path of your file. Most modern IDEs also offer a
          "run" button that you can click.
        </p>
        <p>
          One of the great advantages of Python is its easy-to-use
          libraries and external packages. Since many people use
          Python, there's a wide variety of pre-built packages
          available for many different tasks. The Python Package Index
          (<ExternalLink href="https://pypi.org/">PyPI</ExternalLink>)
          is a collection of software for Python that offers numerous
          packages. You can install Python packages from PyPI using a
          package management tool called "pip".
        </p>
        <p>
          However, Python is not great at dependency management. This
          is why nearly every Python user recommends to use virtual
          environments. Virtual environments are a Python tool for
          dependency management and project isolation. They provide a
          simple solution for a lot of potential problems by helping
          you to:
          <ul>
            <li>Resolve dependency issues</li>
            <li>Create self-contained and reproducible projects</li>
            <li>Avoid system pollution</li>
            <li>Install packages without admin rights</li>
          </ul>
          There are various approaches to creating a virtual
          environment. One option is to use{' '}
          <ExternalLink href="https://docs.python.org/3/library/venv.html">
            venv
          </ExternalLink>
          , a built-in tool in Python. External tools like{' '}
          <ExternalLink href="https://virtualenv.pypa.io/en/latest/">
            virtualenv
          </ExternalLink>{' '}
          or Conda are also commonly used. Conda provides an
          alternative package and environment management approach. It
          not only enables easy creation of virtual environments with
          different Python versions but also introduces an additional
          feature set. It's worth noting that Conda is a separate
          project and is unrelated to pip. It uses an alternative
          package index maintained by the Anaconda project instead of
          PyPI. Conda packages can be installed using the command
          "conda install". As an alternative,{' '}
          <ExternalLink href="https://www.docker.com/">
            Docker
          </ExternalLink>{' '}
          can also be used to create a containerized Python
          development environment. Docker allows you to package your
          Python application along with its dependencies and system
          configurations, ensuring consistency across different
          environments.
        </p>
        <p>
          Alright, now that we've laid the groundwork with our
          introduction to Python, it's time to dive headfirst into the
          fundamental building blocks of this powerful programming
          language. Our next destination: the world of variables and
          the core concepts that form the foundation of Python's
          functionality.
        </p>
        <h3 id="variables">Variables</h3>
        <p>
          In Python, variables are used for storing and managing data.
          Think of variables as containers that can hold values of
          various data types, such as numbers, strings, or complex
          objects. You can assign values to variables using the
          assignment operator =. In Python, there are specific rules
          and conventions for naming variables. Variable names can
          consist of letters, numbers, and underscores, but they must
          begin with a letter or an underscore. It's crucial to note
          that variable names are case-sensitive. Additionally, while
          Python doesn't strictly enforce it, it's highly advisable to
          avoid using built-in Python keywords as variable names to
          prevent potential conflicts. To maintain consistency and
          readability in your code, it's recommended to adhere to the
          naming conventions outlined in{' '}
          <ExternalLink href="https://peps.python.org/pep-0008/#naming-conventions">
            PEP 8
          </ExternalLink>
          .
        </p>
        <p>
          Python uses dynamic typing, which means that you can change
          the type of data stored in a variable during the program's
          execution. You can reassign a variable to hold a different
          data type without explicitly declaring its type. Dynamic
          typing provides flexibility but also requires careful
          handling of variable types to avoid unexpected behavior.
        </p>
        <p>
          Variables have different scopes, which define where in the
          code they can be accessed. In Python, there are primarily
          three levels of variable scope: global scope, local scope
          and enclosing scope. We will discuss the details when
          talking about functions.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/e1f2230491" />
        <h3 id="data-types">Data Types</h3>
        <p>
          In Python, understanding data types is fundamental to
          writing effective code. Let's explore the most common data
          types and get familiar with them. They will be discussed in
          more detail in the following sections.
        </p>
        <h4>Numeric Data Types</h4>
        <p>
          Python supports four different types of numeric data, namely
          integers, long integers, floating point numbers and complex
          numbers. Floating point numbers can be specified either by
          using a decimal point or using exponential notation, e.g.
          1e-3 or 1E-3. In Python, long integers are actually what are
          sometimes called "arbitrary precision" integers which means
          that they can have as many digits as you have typed into the
          computer. In Python 3, the "L" suffix is not required
          anymore. They also have the further advantage that all
          arithmetic performed with long integers does not have
          limited precision like floating point numbers. However,
          while regular integer arithmetic is supported by most
          operating systems, Python has to perform all its own long
          integer arithmetic. Thus, using (many) long integers, will
          slow your programs down. Complex numbers can be entered into
          Python using either the <InlineCode>complex</InlineCode>{' '}
          function or by denoting the complex number as the real
          portion followed by a plus sign and the imaginary part with
          a trailing uppercase or lowercase "J". There must be no
          spaces between the imaginary part and the "J". Both
          components are stored as floating point numbers.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/cd0dea3904" />
        <h4>Strings</h4>
        <p>
          Strings are collections of characters that represent
          arbitrary text in Python code. They can be created by
          enclosing text in single quotes, double quotes, or triple
          quotes (which allow spanning multiple lines). Inside
          strings, special character sequences starting with a
          backslash are interpreted uniquely. Single backslashes can
          also act as continuation characters, similar to using triple
          quotes. To include an actual backslash in a string, you can
          either use two backslashes or employ raw strings by
          prefixing the opening quotation mark with "r".
        </p>
        <p>
          Unicode strings, which use 16 bits to store characters
          instead of 8 bits used by normal strings, can be created by
          prefixing the opening quote character with "u". Arbitrary
          Unicode characters can be specified using "\u" inside a
          string. Combining a Unicode string with a regular string
          results in a Unicode string.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c2c2a8cc11" />
        <h5>String Operations</h5>
        <p>
          The following sections describe some of the most important
          operations available for working with strings.
        </p>
        <h6>Concatenation</h6>
        <p>
          Strings can be concatenated using the + operator, creating a
          new string that combines the originals. Strings can be also
          concatenated with variables.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1d49685948" />
        <h6>String Formatting</h6>
        <p>
          In addition to creating and manipulating strings, it's
          essential to know how to format them effectively. String
          formatting allows you to combine variables, constants, and
          text in a way that makes your code more readable and
          user-friendly. There are various string formatting
          techniques, including concatenation, "%" formatting, and the
          modern approach using f-strings (for Python version 3.6 and
          above). You can also use the{' '}
          <InlineCode>str.format()</InlineCode> method, which provides
          another flexible way to format strings.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/60cf41bfe5" />
        <h6>Repetition</h6>
        <p>
          When using an asterisk (*) between a string and an integer a
          new string is created which contains the old string repeated
          by the integer value. The order of the arguments does not
          matter.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c4ad4cc54f" />
        <h6>Indexing and Slicing</h6>
        <p>
          Strings in Python support indexing and slicing. A single
          character can be extracted from a string by appending the
          index of the desired character surrounded by square
          brackets. Keep in mind that the index starts at zero in
          Python. If the value inside the brackets is less than zero,
          Python counts from the end of the string. The last character
          in a string can be for example accessed using a subscript of
          -1.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0d52f421fd" />
        <p>
          A contiguous part of a string (called a slice) can be
          extracted by using a subscript consisting of a starting
          index followed by a colon and a ending index after it.
          Notice that the slicing stop position is exclusive, i.e. the
          slicing stops one position before the second value. If a
          slice starts at the beginning of a string or continues until
          the end, the first or second index can be omitted,
          respectively. It is also possible to use variables and
          integer constants for indexing and slicing:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/81099f478b" />
        <h6>Functions and Methods</h6>
        <p>
          Python provides some useful functions and methods for
          working with strings. The <InlineCode>len()</InlineCode>{' '}
          function returns the number of characters which a string
          contains. Strings in Python are immutable objects, i.e. the
          value of a string can't be changed in place. To change the
          value of a string, a method needs to be invoked on the
          variable containing the string and the value of this
          operation needs to be reassigned to the desired variable.
          Python offers a wide variety of string methods. The{' '}
          <InlineCode>split()</InlineCode> and{' '}
          <InlineCode>join()</InlineCode> methods are among the most
          useful. The <InlineCode>split()</InlineCode> method returns
          a list whose elements are a character or string in the
          original string splitted at the optionally specified
          separator. If no argument is specified, one or more
          whitespace characters are used as the default separator
          character. The following table shows an overview over some
          useful string methods:
          <Table
            columns={['Method', 'Description']}
            data={[
              [
                'str.upper()',
                'Converts all characters in the string to uppercase.',
              ],
              [
                'str.lower()',
                'Converts all characters in the string to lowercase.',
              ],
              [
                'str.strip()',
                'Removes leading and trailing whitespace from the string.',
              ],
              [
                'str.split()',
                'Splits the string into a list of substrings based on a delimiter.',
              ],
              [
                'str.join()',
                'Joins a list of strings into a single string using the provided delimiter.',
              ],
              [
                'str.replace()',
                'Replaces occurrences of a substring with another substring.',
              ],
              [
                'str.find()',
                'Returns the index of the first occurrence of a substring (or -1 if not found).',
              ],
              [
                'str.startswith()',
                'Checks if the string starts with a specified substring.',
              ],
              [
                'str.endswith()',
                'Checks if the string ends with a specified substring.',
              ],
              [
                'str.isalpha()',
                'Checks if all characters in the string are alphabetic.',
              ],
            ]}
          />
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c7fb7570ab" />
        <h4>Booleans</h4>
        <p>
          Booleans represent either <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode> values and are often used in
          conditional statements and logic.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/d6b3e1f582" />
        <h4>None</h4>
        <p>
          In Python, None is a special value used to indicate the
          absence of a value or to initialize variables when you don't
          have a specific value to assign. It's often employed as a
          placeholder in situations where a variable or result is
          expected but hasn't been determined yet.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/a1b65a8f51" />
        <h4>Data Structures</h4>
        <p>
          Python provides various data structures to efficiently
          organize and manipulate data. These structures help manage
          collections of data items, making it easier to work with
          different types of information. A Python list is an ordered
          collection which allows to store objects of different data
          types. A Python dictionary is an unordered collection of
          data consisting of key/value pairs. A tuple is an ordered
          collection of different data types like a list, but tuples
          are immutable, i.e. they can not be modified once they are
          created. A set is a collection of data types that is similar
          to list and tuple, but a set is not an ordered collection of
          items and can only store unique items. These data structures
          serve various purposes, and their choice depends on the
          specific requirements of your program. We will delve deeper
          into Python data structures later on.
        </p>
        <h3 id="comments">Comments</h3>
        <p>
          Comments are a crucial aspect of Python programming. They
          serve the purpose of documenting your code and providing
          context to both others who may read your code and your
          future self. Comments are lines of text that are not
          executed by the Python interpreter and are preceded by the{' '}
          <InlineCode>#</InlineCode> symbol.
        </p>
        <p>
          Single-line comments are used for brief explanations within
          your code. While Python doesn't have a specific syntax for
          multi-line comments, you can use triple-quotes (
          <InlineCode>'''</InlineCode> or <InlineCode>"""</InlineCode>
          ) to create multi-line comment blocks, although they are
          typically used for so-called docstrings, which we will
          discuss in the section about functions.
        </p>
        <p>
          There are different opinions on how and when to comment code
          among programmers, but using meaningful variable and
          function names is considered best practive. Clear, concise
          single-line comments can be used if needed, but are often a
          sign of code smell. However, when documenting functions or
          modules for wider use or sharing, adhering to the docstring
          conventions and practices is recommended to ensure that
          others can understand and use your code effectively.
        </p>
        <h3 id="operators">Operators</h3>
        <p>
          In Python, operators are fundamental elements used to
          perform various operations on values and variables. In this
          section, we will explore different types of operators in
          Python.
        </p>
        <h4>Assigment Operators</h4>
        <p>
          One of the fundamental operations in any programming
          language is the assignment statement. It allows us to
          associate a variable name with a value, enabling us to
          manipulate our data effectively. In Python, like many other
          programming languages, the equal sign (=) is used for
          assignment. Assignment statements can be chained together to
          set multiple variables to the same value. Multiple
          assignments are also possible by using a comma-separated
          list of variables and expressions.
        </p>
        <p>
          Without diving too deep into the internal details of Python,
          there is one crucial aspect of the assignment statement
          which needs to be understood to program effectively in
          Python. When assigning values to variables, whether they are
          numbers, strings, or expressions involving such types,
          Python stores these values in memory and associates them
          with their assigned variable names. However, when making
          assignments of one variable to another, Python actually
          stores a reference to the variable. Instead of creating a
          new copy of the contents of the original variable, it stores
          information about where the original variable is stored in
          memory. When the new variable is later referenced, it refers
          back to this location to find the value of the variable. For
          scalar variables (e.g., numbers and strings), this behavior
          generally doesn't produce unexpected results since Python
          automatically updates the values of any variables referring
          to another value once it's changed. However, with mutable
          objects such as lists, changes within the list do not
          trigger this updating mechanism, which can lead to
          surprising results. If you genuinely want to make a copy of
          a list instead of merely storing a reference, you can use
          Python's <InlineCode>copy</InlineCode> module. We will
          discuss this in more detail when talking about data
          structures.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/b38470ba30" />
        <p>
          In addition to the basic assignment operator (=), Python
          also provides several other assignment operators, as shown
          in the following table:
          <Table
            columns={['Operator', 'Description']}
            data={[
              [
                '=',
                'Assigns the value on the right to the variable on the left.',
              ],
              [
                '+=',
                'Adds the value on the right to the variable on the left and assigns the result to the variable.',
              ],
              [
                '-=',
                'Subtracts the value on the right from the variable on the left and assigns the result to the variable.',
              ],
              [
                '*=',
                'Multiplies the variable on the left by the value on the right and assigns the result to the variable.',
              ],
              [
                '/=',
                'Divides the variable on the left by the value on the right and assigns the result to the variable.',
              ],
              [
                '%=',
                'Calculates the modulus of the variable on the left and the value on the right, then assigns the result to the variable.',
              ],
              [
                '//=',
                'Performs floor division on the variable on the left and the value on the right, then assigns the result to the variable.',
              ],
              [
                '**=',
                'Raises the variable on the left to the power of the value on the right and assigns the result to the variable.',
              ],
              [
                '&=',
                'Performs a bitwise AND operation between the variable on the left and the value on the right, then assigns the result to the variable.',
              ],
              [
                '|=',
                'Performs a bitwise OR operation between the variable on the left and the value on the right, then assigns the result to the variable.',
              ],
              [
                '^=',
                'Performs a bitwise XOR operation between the variable on the left and the value on the right, then assigns the result to the variable.',
              ],
              [
                '<<=',
                'Shifts the bits of the variable on the left to the left by the number of positions specified by the value on the right and assigns the result to the variable.',
              ],
              [
                '>>=',
                'Shifts the bits of the variable on the left to the right by the number of positions specified by the value on the right and assigns the result to the variable.',
              ],
            ]}
          />
        </p>
        <h4>Arithmetic Operators</h4>
        <p>
          Arithmetic operators are used to perform basic mathematical
          operations in Python, including addition, subtraction,
          multiplication, and division. Python supports all the binary
          arithmetic operators shown in the following table.
          <Table
            columns={['Operator', 'Description']}
            data={[
              ['+', 'Adds two operands.'],
              [
                '-',
                'Subtracts the right operand from the left operand.',
              ],
              ['*', 'Multiplies two operands.'],
              [
                '/',
                'Divides the left operand by the right operand (float division).',
              ],
              [
                '//',
                'Divides the left operand by the right operand and returns the floor value (integer division).',
              ],
              [
                '%',
                'Returns the remainder when the left operand is divided by the right operand.',
              ],
              [
                '**',
                'Raises the left operand to the power of the right operand.',
              ],
            ]}
          />
          A binary operator operates on exactly two elements, one on
          each side of the operator's symbol. When performing
          operations on integers, Python performs integer arithmetic
          unless one of the operands is a floating-point number.
          Python also provides unary operators for plus and minus. Any
          expression returning a single numeric value can be preceded
          either by a minus or plus sign.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9ffb1493fb" />
        <p>
          The precedence of Arithmetic Operators in Python is as
          follows:
          <ol>
            <li>P - Parentheses</li>
            <li>E - Exponentiation</li>
            <li>
              M - Multiplication (Multiplication and division have the
              same precedence)
            </li>
            <li>D - Division</li>
            <li>
              A - Addition (Addition and subtraction have the same
              precedence)
            </li>
            <li>S - Subtraction</li>
          </ol>
        </p>
        <h4>Comparison Operators</h4>
        <p>
          Comparison operators, also known as relational operators,
          are used in Python to compare values. They evaluate to
          either <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode> based on the specified
          condition. The comparison operators in Python are shown in
          the following table.
          <Table
            columns={['Operator', 'Description']}
            data={[
              ['==', 'Equal to: Checks if the operands are equal.'],
              [
                '!=',
                'Not equal to: Checks if the operands are not equal.',
              ],
              [
                '<',
                'Less than: Checks if the left operand is less than the right operand.',
              ],
              [
                '>',
                'Greater than: Checks if the left operand is greater than the right operand.',
              ],
              [
                '<=',
                'Less than or equal to: Checks if the left operand is less than or equal to the right operand.',
              ],
              [
                '>=',
                'Greater than or equal to: Checks if the left operand is greater than or equal to the right operand.',
              ],
            ]}
          />
          In Python, comparison operators have lower precedence than
          arithmetic operators. All comparison operators have the same
          precedence order.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9b800fb6e4" />
        <h4>Logical Operators</h4>
        <p>
          Logical operators are used to perform logical operations
          such as "AND," "OR," and "NOT" in Python. They are typically
          used to combine conditional statements and create more
          complex conditions. The precedence of Logical Operators in
          Python is as follows:
          <ol>
            <li>Logical NOT</li>
            <li>Logical AND</li>
            <li>Logical OR</li>
          </ol>
          The following example illustrates how to use logical
          operators in Python.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/129d457075" />
        <h4>Bitwise Operators</h4>
        <p>
          Bitwise operators are used to operate on binary numbers and
          perform bit-by-bit operations. An overview over the bitwise
          operators in Python is shown in the following table.
          <Table
            columns={['Operator', 'Description']}
            data={[
              [
                '&',
                'Bitwise AND: Performs a bitwise AND operation on the corresponding bits of the operands.',
              ],
              [
                '|',
                'Bitwise OR: Performs a bitwise OR operation on the corresponding bits of the operands.',
              ],
              [
                '^',
                'Bitwise XOR: Performs a bitwise XOR (exclusive OR) operation on the corresponding bits of the operands.',
              ],
              [
                '~',
                'Bitwise NOT: Inverts the bits of the operand, changing 1s to 0s and vice versa.',
              ],
              [
                '<<',
                'Left Shift: Shifts the bits of the left operand to the left by the number of positions specified by the right operand.',
              ],
              [
                '>>',
                'Right Shift: Shifts the bits of the left operand to the right by the number of positions specified by the right operand.',
              ],
            ]}
          />
        </p>
        <p>
          The precedence of Bitwise Operators in Python is as follows:
          <ol>
            <li>Bitwise NOT</li>
            <li>Bitwise Shift</li>
            <li>Bitwise AND</li>
            <li>Bitwise XOR</li>
            <li>Bitwise OR</li>
          </ol>
        </p>
        <LazyIframe src="https://trinket.io/embed/python/63e371be96" />
        <h4>Identity and Membership Operators</h4>
        <p>
          In Python, identity and membership operators are essential
          for comparing and checking the relationships between values,
          variables, and sequences. The <InlineCode>is</InlineCode>{' '}
          operator is used to check if two values or variables refer
          to the same object in memory. It returns{' '}
          <InlineCode>True</InlineCode> if they do and{' '}
          <InlineCode>False</InlineCode> otherwise. It is not used to
          compare the values themselves, but rather their identity.
          The <InlineCode>is not</InlineCode> operator is the negation
          of is. It returns <InlineCode>True</InlineCode> if two
          values or variables do not refer to the same object and{' '}
          <InlineCode>False</InlineCode> if they do.
        </p>
        <p>
          The <InlineCode>in</InlineCode> operator is used to check if
          a value or variable is present in a sequence (e.g., a list,
          tuple, string, or set). It returns{' '}
          <InlineCode>True</InlineCode> if the value is found in the
          sequence and <InlineCode>False</InlineCode> otherwise. The{' '}
          <InlineCode>not in</InlineCode> operator is the negation of{' '}
          <InlineCode>in</InlineCode>.
        </p>
        <p>
          Python provides a concise way to evaluate an expression
          based on a condition using ternary operators. The basic
          syntax is{' '}
          <InlineCode>
            [on_true] if [expression] else [on_false]
          </InlineCode>
          . This allows you to write compact code instead of needing a
          multi-line if-else statement. Ternary operators are
          especially useful when you need to assign a value to a
          variable based on a condition in a single line.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0ca3472fc8" />
        <h3 id="control-structures">Control Structures</h3>
        <h4>Conditions</h4>
        <p>
          In Python, control structures like the{' '}
          <InlineCode>if</InlineCode> statement, along with optional{' '}
          <InlineCode>elif</InlineCode> and{' '}
          <InlineCode>else</InlineCode> statements, are the foundation
          for executing conditional logic in your programs. The{' '}
          <InlineCode>if</InlineCode> statement evaluates the
          expression following it. If the expression is true, Python
          executes the statement(s) that follow. If the expression is
          false, Python continues with the{' '}
          <InlineCode>elif</InlineCode> statement (if there is one),
          and tests that expression. It proceeds to test the
          expressions associated with any{' '}
          <InlineCode>elif</InlineCode> statements in order, executing
          the first set of statements for which the expression is
          true. If none of the <InlineCode>elif</InlineCode>{' '}
          expressions are true, and there is an{' '}
          <InlineCode>else</InlineCode> statement, Python executes the
          statement(s) associated with the{' '}
          <InlineCode>else</InlineCode>. If there's no{' '}
          <InlineCode>else</InlineCode> statement, Python simply moves
          on to the statements following the{' '}
          <InlineCode>if</InlineCode> block. It's important to note
          that once Python encounters a true expression associated
          with an <InlineCode>if</InlineCode> or{' '}
          <InlineCode>elif</InlineCode> statement, it executes the
          corresponding statement(s) and doesn't evaluate any other
          expressions that follow.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/b9cb6a2b5c" />
        <h4>Loops</h4>
        <p>
          Python provides two primary types of loops: the{' '}
          <InlineCode>for</InlineCode> loop and the{' '}
          <InlineCode>while</InlineCode> loop.
        </p>
        <p>
          Python, like other programming languages, provides a{' '}
          <InlineCode>for</InlineCode> loop which allows you to
          iterate. Although, the <InlineCode>for</InlineCode> loop is
          very useful, there is a more "pythonic" and powerful way for
          iteration in Python. The <InlineCode>for in</InlineCode>{' '}
          loop allows you to iterate over all the values in a sequence
          (e.g. string, list or tuple), performing the same task in
          each element. If the elements of the sequence being iterated
          over contain tuples or lists, a comma separated list can be
          used to unpack each individual element of the sequence. If
          you need an index, you can use{' '}
          <InlineCode>enumerate</InlineCode>.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/a9f718e2e0" />
        <p>
          The <InlineCode>for</InlineCode> loop provides a great way
          to process the elements of a sequence. However, sometimes it
          is necessary to do some repetitive computation which is not
          based on an array. In those cases, the{' '}
          <InlineCode>while</InlineCode> loop can be used. When Python
          encounters a <InlineCode>while</InlineCode> loop, it firsts
          tests the expression provided. If the expression is false
          and there's an <InlineCode>else</InlineCode> clause, Python
          executes the statements following the{' '}
          <InlineCode>else</InlineCode>. Without an{' '}
          <InlineCode>else</InlineCode> clause, if the expression is
          false, control moves to the first statement after the{' '}
          <InlineCode>while</InlineCode> loop. If the expression is
          true, Python executes the statements following the{' '}
          <InlineCode>while</InlineCode> statement. Once those
          statements are completed, the expression is tested again,
          and the process repeats. As long as the expression remains
          true, Python continues executing the statements after the
          <InlineCode>while</InlineCode>. When the expression becomes
          false, the statements after the{' '}
          <InlineCode>else</InlineCode> (if present) are executed.
        </p>
        <p>
          It's worth mentioning that Python programmers often use{' '}
          <InlineCode>while</InlineCode> loops in a somewhat
          unconventional way. They may create "infinite" loops and
          control when to exit the loop with statements inside the
          loop. To exit a loop (<InlineCode>for</InlineCode> or{' '}
          <InlineCode>while</InlineCode>) prematurely, you can use the{' '}
          <InlineCode>break</InlineCode> statement. The{' '}
          <InlineCode>continue</InlineCode> statement, on the other
          hand, is used to skip the remaining part of the current
          iteration and move on to the next one. In a{' '}
          <InlineCode>for</InlineCode> loop, the loop variable's value
          is automatically incremented after a{' '}
          <InlineCode>continue</InlineCode> statement, so the next
          iteration proceeds as usual.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/63c61bb123" />
        <h3 id="data-structures">Data Structures</h3>
        <p>
          Data structures are a way of organizing data so that it can
          be accessed more efficiently depending upon the situation.
          They are the fundamentals of any programming language around
          which a program is built. Python provides several built-in
          data structures, each with its unique characteristics and
          use cases. Understanding these data structures is essential
          for effective programming, as they play a fundamental role
          in organizing and processing data in Python. Let's dive into
          these data structures and their capabilities.
        </p>
        <h4>Lists</h4>
        <p>
          Lists serve as a fundamental tool in Python for holding
          collections of objects that are indexed using numerical
          positions. These objects within a list can span various
          types, including numbers, strings, functions, user-defined
          objects, and even other lists. This versatility enables the
          creation of complex data structures with ease. To define a
          list in Python, enclose a sequence of elements you want
          within square brackets, separated by commas. To initialize
          an empty list, simply use square brackets without any
          elements inside. Notably, the items in a list can have
          different data types. Accessing individual elements within a
          list is achieved by employing square brackets after the
          list's name, specifying the index of the desired element.
          It's important to remember that Python employs zero-based
          indexing, meaning the first element corresponds to index 0.
          In the case of nested lists (lists within lists), you can
          utilize additional sets of square brackets to access
          individual elements. To get the number of elements within a
          list, Python offers the built-in{' '}
          <InlineCode>len()</InlineCode> function.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/179b14e949" />
        <h5>List Indexing and Slicing</h5>
        <p>
          The slicing operations introduced in the section about
          strings are equally applicable to lists, with a particularly
          useful extension. In addition to utilizing slicing to
          extract a section of a list, you can employ slicing to
          assign values to elements within a list, indicated by a
          slice positioned on the left side of an equal sign. This
          distinction arises from the fact that lists are mutable
          objects, while strings are immutable. When assigning values
          using this approach, if the count of elements in the list on
          the right side of the assignment doesn't match the number of
          elements suggested by the slice's subscript, the list will
          automatically adjust its size to accommodate the assignment.
          Conversely, assignments performed via a single subscript
          will consistently maintain the list's length. Slices further
          offer the capability to remove elements from a list.
          Alternatively, the <InlineCode>del</InlineCode> statement
          can be employed to remove items from a list. To use the{' '}
          <InlineCode>del</InlineCode> statement, specify the element
          or slice of the list that requires deletion. Another
          important use of slices is to make a separate modifiable
          copy of a list. We will discuss later why this is important.
          In this case, a slice is created without a starting and
          ending index.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1c6c2fe35d" />
        <h5>List Operators</h5>
        <h6>Concatenation</h6>
        <p>
          To merge the contents of two lists, the plus sign is used to
          concatenate them. The outcome is a unified list whose length
          equals the sum of both original lists' lengths. This new
          list contains all the elements from the first list followed
          by all the elements from the second list. List concatenation
          only works when combining two lists. To add a scalar to the
          end of a list, you either need to surround the scalar with
          square brackets or use the <InlineCode>append()</InlineCode>{' '}
          method.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ef8c8f064f" />
        <h6>Repetition</h6>
        <p>
          As for strings, the asterisk is overloaded for lists to
          serve as a repetition operator, Applying repetition to a
          list results in a single list with the elements of the
          original list repeated as many times as specified. A list
          consisting other lists can be created by surrounding a list
          to be repeated with an extra set of square brackets.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/74423edc47" />
        <h6>
          The <InlineCode>in</InlineCode> Operator
        </h6>
        <p>
          The <InlineCode>in</InlineCode> operator provides an
          extremely convenient technique for determining whether a
          specific value resides within a list. These evaluations are
          structured by positioning a value on the left side of the
          operator and a list on the right side. The outcome is either{' '}
          <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode>, rendering it highly suitable
          for conditional statements. It's important to exercise
          caution when constructing expressions employing the{' '}
          <InlineCode>in</InlineCode> operator, as an exact match in
          both type and value is necessary for a{' '}
          <InlineCode>True</InlineCode> result. Moreover, the{' '}
          <InlineCode>in</InlineCode> operator works seamlessly with
          expressions that evaluate to elements within a list.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/be273e1259" />
        <h6>List Comprehension</h6>
        <p>
          List comprehensions are a concise and elegant way to create
          lists in Python. They allow you to generate a new list by
          applying an expression to each item in an existing iterable
          (like a list, tuple, or range) and optionally applying a
          condition to filter the items. List comprehensions not only
          make your code more compact, but they also enhance its
          readability by encapsulating complex operations in a
          comprehensible format.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/684e868e0f" />
        <h6>Functions and Methods for Lists</h6>
        <p>
          We already learnt that the <InlineCode>len()</InlineCode>{' '}
          function will return the number of elements in a list. But
          there are more built-in functions and methods for lists in
          Python. For a single list input, the{' '}
          <InlineCode>min()</InlineCode> function extracts the
          smallest element from the list, while the{' '}
          <InlineCode>max()</InlineCode> function retrieves the
          largest. To append a single element at the end of a list,
          the <InlineCode>append()</InlineCode> method can be used. If
          you need to add several elements to the end of a list,
          either the concatenation operator or the{' '}
          <InlineCode>extend()</InlineCode> method can be employed. If
          your intent is to insert an element at a position other than
          the end of the list, the <InlineCode>insert()</InlineCode>{' '}
          method proves useful. This method demands two arguments: the
          index for the insertion location and the item itself.
          Notably, a single element can be inserted using{' '}
          <InlineCode>insert()</InlineCode>, while for multiple
          insertions, slicing can be utilized. When the objective
          involves eliminating an item from a list based on its value,
          the <InlineCode>remove()</InlineCode> method proves
          invaluable. It removes only the initial occurrence of the
          value within the list. Both the{' '}
          <InlineCode>reverse()</InlineCode> and{' '}
          <InlineCode>sort()</InlineCode> methods operate in place,
          meaning they change the original order of elements within
          the list. If preservation of the initial order is essential,
          it's advisable to generate a copy of the list. By default,
          the <InlineCode>sort()</InlineCode> method sorts its numeric
          arguments in numerical order and string arguments in
          alphabetical order. Recall that lists can contain arbitrary
          objects, so <InlineCode>sort()</InlineCode> needs to be very
          flexible. In general, it sorts scalar numeric values before
          scalar string values and lists by first comparing their
          initial elements and continuing through the available list
          elements until one list differs from the other. The{' '}
          <InlineCode>count()</InlineCode> method accepts a single
          argument representing the value to be located and calculates
          the frequency of that value within the list. On the other
          hand, the <InlineCode>index()</InlineCode> method offers the
          index (subscript) of the first occurrence of a specified
          value.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/697878d467" />
        <h4>Tuples</h4>
        <p>
          Tuples, like lists, are a fundamental data structure in
          Python, used to store collections of items. They can contain
          elements of various data types, including numbers, strings,
          and even other tuples. Tuples are similar to lists but there
          is one important difference, namely that tuples are not
          mutable. This means that once a tuple is created, its
          elements can't be modified in place. The immutability of
          tuples makes them valuable in scenarios where you want to
          ensure that the data remains constant throughout the
          program's execution. Tuples are constructed by enclosing
          their values within parentheses. When a tuple is not
          embedded within an expression, the parentheses may be
          omitted. To create an empty tuple, simply utilize a pair of
          empty parentheses. However, due to the use of parentheses
          for grouping in arithmetic expressions, it is essential to
          include a comma after the sole element to explicitly denote
          a tuple with only one element in an assignment statement.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/cb306ac40b" />
        <h5>Operators and Indexing for Tuples</h5>
        <p>
          The same operators as mentioned in the previous section for
          lists apply to tuples. Keep in mind that tuples are
          immutable. Thus, slicing operations for tuples are more
          similar to strings than lists. Slicing can be used to
          extract parts of a tuple, but not to change it.
        </p>
        <h5>Functions and Methods for Tuples</h5>
        <p>
          There are no methods for tuples. However, tuples and list
          can be easily converted to each other using the built-in
          functions <InlineCode>list</InlineCode> and{' '}
          <InlineCode>tuple</InlineCode>.
        </p>
        <h4>Dictionaries</h4>
        <p>
          Dictionaries in Python share similarities with lists, as
          they can store arbitrary objects and be nested to any
          desired depth. However, unlike lists, dictionaries are
          indexed by keys, which can be any immutable object, such as
          strings or tuples. Let's delve into this concept with a
          straightforward example: imagine a scenario where we want to
          store student matriculation numbers as tuples inside a list,
          where the first tuple element represents the student's name,
          and the second element is their matriculation number.
          However, if we wish to retrieve the matriculation number of
          a specific student, we'd need to search through each element
          in the list to find the tuple with the student's name as the
          first element before we can access the desired number. With
          a dictionary, we can use the student's name as the index,
          often referred to as a key. This significantly simplifies
          the process of retrieving the information we need:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/18505c9294" />
        <p>
          As the example above illustrates, a dictionary can be
          initialized using a comma-separated list of key/value pairs
          enclosed in curly braces. An empty dictionary can be created
          with a pair of empty curly braces. It's important to note
          that dictionary keys are not limited to strings, and they
          don't need to be of the same data type. However, it's
          crucial to remember that mutable objects, such as lists,
          cannot be used as dictionary keys.
        </p>
        <h5>Operators and Indexing for Dictionaries</h5>
        <p>
          You can add key/value pairs to a dictionary using assignment
          statements, and if you need to remove a specific key/value
          pair from a dictionary, you can use the{' '}
          <InlineCode>del</InlineCode> statement for this purpose. You
          can use the <InlineCode>in</InlineCode> operator to check if
          a specific key exists in a dictionary. It returns{' '}
          <InlineCode>True</InlineCode> if the key is present and
          <InlineCode>False</InlineCode> otherwise.
        </p>
        <h5>Functions and Methods for Dictionaries</h5>
        <p>
          Dictionaries in Python offer several built-in methods
          specifically designed for working with dictionaries. These
          methods provide convenient ways to perform various
          operations on dictionaries. Let's take a look at some
          examples:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/a0e8e517ba" />
        <p></p>
        <h4>Sets</h4>
        <p>
          Python's built-in set type is similar to dictionaries. Sets
          are unordered and its elements are unique. A set itself can
          be modified, but the elements in the set must be immutable.
          There are two ways to create a set in Python: first, you can
          create a set using the built-in{' '}
          <InlineCode>set()</InlineCode> function or alternately, a
          set can be defined using curly braces. To define an empty
          set, the <InlineCode>set()</InlineCode> function needs to be
          used. Recall that Python interprets empty curly braces as an
          empty dictionary. The elements in a set can be objects of
          different types. However, keep in mind that set elements
          must be immutable. Thus, a tuple may be included in a set,
          but lists and dictionaries are mutable, so they can't be set
          elements.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/4cc37ba9e0" />
        <h5>Functions and Methods for Sets</h5>
        <p>
          As for lists, the <InlineCode>len()</InlineCode> function
          can be used to get the number of elements in a set and the{' '}
          <InlineCode>in</InlineCode> and{' '}
          <InlineCode>not in</InlineCode> operators can be used to
          test for membership. However, many of the operations that
          can be used for Python's other data types, don't make sense
          for sets. For example, sets can't be indexed or sliced.
          Nevertheless, Python provides a variety of operations on set
          objects which are similar to the operations defined for
          mathematical sets. Set union of two or more sets can be
          performed with the "|" operator or with the{' '}
          <InlineCode>union()</InlineCode> method. The resulting set
          contains all elements that are present in any of the
          specified sets. To compute the intersection of two or more
          sets, i.e. return a set containing only elements that are
          present in all of the specified sets, the "&" operator or{' '}
          <InlineCode>intersection()</InlineCode> method can be used.
          The difference between two or more sets can be computed
          using the "-" operator or the{' '}
          <InlineCode>difference()</InlineCode> method. For two sets,
          this will return a set containing all elements that are in
          the first set, but not in the second set. When multiple sets
          are specified, the operation is performed from left to
          right. There are many more operations available such as{' '}
          <InlineCode>update()</InlineCode> for updating a set,{' '}
          <InlineCode>add()</InlineCode> to add an element to a set,{' '}
          <InlineCode>remove()</InlineCode> to remove an element from
          a set and <InlineCode>clear()</InlineCode> to remove all
          elements from a set. For more details, refer to the{' '}
          <ExternalLink href="https://docs.python.org/3.11/library/stdtypes.html#set">
            Python documentation
          </ExternalLink>{' '}
          .There's also another built-in type in Python called{' '}
          <InlineCode>frozenset</InlineCode> which is exactly the same
          as set, but is immutable.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ab8ea2aa12" />
        <h3 id="functions-and-modules">Functions and Modules</h3>
        <h4>Functions</h4>
        <p>
          Functions are a fundamental component of any programming
          language for two primary reasons. First, they enable code
          reusability, eliminating the need to duplicate and modify
          code each time it is used. Second, functions allow you to
          logically isolate various sub-tasks that inevitably arise
          when working on a program. This programming approach is
          known as modular programming and is generally considered a
          best practice for writing readable and maintainable code.
        </p>
        <p>
          In Python, functions are treated as objects. As a result,
          they can be assigned to variables, stored in lists or
          tuples, passed as arguments to other functions, and more.
          However, functions possess a unique property that
          distinguishes them from other Python objects: they can
          accept a list of arguments enclosed in parentheses and
          optionally return a value. You may already be familiar with
          some of Python's built-in functions, such as{' '}
          <InlineCode>len()</InlineCode>, and you've encountered
          methods, which are similar to functions and defined in a
          similar manner. In this section, we will delve into various
          aspects of functions, including how to create and import
          them into your programs.
        </p>
        <h5>Variable Scoping</h5>
        <p>
          In Python, you can typically reference variables anywhere in
          your program. However, when you define a function, Python
          creates a distinct namespace within that function. A
          namespace serves as a mapping between object names in your
          program and their corresponding memory locations where
          Python stores their values. Consequently, when a variable is
          created inside a function, Python recognizes it as a local
          variable within that function's namespace, distinct from
          variables with the same name defined elsewhere in the
          program. You can also reference a variable inside a function
          that already exists in your program at the time the function
          is called. Additionally, you can declare global variables
          using the <InlineCode>global</InlineCode> statement, though
          this should be only used for situations where no other
          reasonable solution is available. Consequently, we won't
          delve into global variables in detail here.
          <LazyIframe src="https://trinket.io/embed/python/af84c02554" />
          When Python attempts to resolve the reference of a name in
          your program, names within a function's local namespace take
          precedence, followed by names of global objects or objects
          imported into the global namespace from a module. Finally,
          built-in object names are searched as a last resort. Due to
          this search order, Python's scoping is sometimes referred to
          as following the LGB rule.
        </p>
        <h5>Function Basics</h5>
        <p>
          In Python, functions are defined using the{' '}
          <InlineCode>def</InlineCode> statement. The function's name
          follows the <InlineCode>def</InlineCode> keyword, followed
          by a parenthesized list of arguments to be passed to the
          function. If a function does not require any arguments, an
          empty set of parentheses is used. A colon (:) comes after
          the parenthesized list. On the next line, an indented
          triple-quoted string, known as a docstring, provides
          documentation about the function. While not strictly
          necessary, docstrings are good practice. Python docstrings
          can be written in several formats. The{' '}
          <ExternalLink href="https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings">
            Google
          </ExternalLink>{' '}
          and{' '}
          <ExternalLink href="https://numpydoc.readthedocs.io/en/latest/format.html">
            Numpy
          </ExternalLink>{' '}
          formats are probably the most common ones. The function body
          follows the <InlineCode>def</InlineCode> line and the
          optional docstring. The function returns control to the
          calling environment when it encounters a{' '}
          <InlineCode>return</InlineCode> statement or when it reaches
          the end of the function body. If the function lacks a{' '}
          <InlineCode>return</InlineCode> statement, calling it will
          return the value <InlineCode>None</InlineCode>. To call a
          function, you refer to its name followed by a parenthesized
          list of arguments. For functions with no arguments, you
          simply use empty parentheses.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/b84ae49f6c" />
        <h5>Named Arguments and Default Values</h5>
        <p>
          When passing arguments to a function without specifying
          their names, Python assumes that you've arranged the
          arguments in the order they were defined in the function. To
          mitigate the need to remember argument order, Python allows
          you to use named arguments. When calling a function, you can
          precede some or all of the arguments with a name and an
          equal sign, making it clear which argument corresponds to
          which parameter in the function. For added flexibility, when
          defining a function, Python allows you to specify default
          values for some or all of the arguments, making it optional
          for users to provide these arguments. To set a default value
          when defining a function, use a syntax similar to naming
          arguments when calling a function, appending an equal sign
          followed by the desired default value. When combining named
          and unnamed arguments in a function call, unnamed arguments
          must precede named ones in the argument list. Thus, place
          required arguments before optional ones in the function's
          argument list.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0b222675df" />
        <h5>Variable Number of Arguments</h5>
        <p>
          In some cases, it's impossible to predict in advance how
          many arguments a function will receive. By designating a
          function argument with a name beginning with an asterisk,
          Python will collect all unnamed arguments passed to the
          function into a tuple, which can be accessed using that
          argument's name. A similar technique can be employed to
          create functions that can handle an unlimited number of
          keyword-argument pairs. If an argument in a function is
          prefixed with two asterisks, Python will collect all
          keyword-argument pairs that were not explicitly declared as
          arguments into a dictionary. This argument must be the last
          one in the function definition. This approach enables you to
          write a function that accepts any named parameter, even if
          you don't know the parameter name when writing the function.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/cabd905e6a" />
        <h5>Functional Programming and Anonymous Functions</h5>
        <p>
          When you need to perform the same operation on a list of
          objects, an alternative to using a{' '}
          <InlineCode>for</InlineCode> loop is the{' '}
          <InlineCode>map</InlineCode> function. This function accepts
          another function as its first argument and one or more lists
          as additional arguments. The number of provided lists must
          match the number of arguments expected by the mapped
          function. Python offers the <InlineCode>lambda</InlineCode>{' '}
          operator for creating anonymous functions when you only need
          a function once. Anonymous functions are limited to a single
          statement, which becomes the value returned by the{' '}
          <InlineCode>lambda</InlineCode> operator. Instead of
          enclosing the arguments in parentheses, you list them after
          the <InlineCode>lambda</InlineCode> keyword, separated by
          commas.
        </p>
        <p>
          Another functional programming tool in Python is the{' '}
          <InlineCode>filter</InlineCode> function. Like{' '}
          <InlineCode>map</InlineCode>, it takes a function as its
          first argument and a list as its second argument. However,{' '}
          <InlineCode>filter</InlineCode> returns a new list
          containing only those elements for which the function
          returns <InlineCode>True</InlineCode>. You might also recall
          list comprehensions as an alternative way to apply an
          expression to all elements of a list. In fact, a list
          comprehension with a single <InlineCode>for</InlineCode>{' '}
          clause is similar to a call to <InlineCode>map</InlineCode>.
          By adding an <InlineCode>if</InlineCode> clause to the
          comprehension, it becomes similar to embedding a call to{' '}
          <InlineCode>filter</InlineCode> within a{' '}
          <InlineCode>map</InlineCode>.
        </p>
        <p>
          Finally, the <InlineCode>reduce</InlineCode> function takes
          a function with exactly two arguments as its first argument
          and a list as its second argument. It successively applies
          the function to the list's elements, using the current
          result as the first argument and an element from the list as
          the second argument. <InlineCode>reduce</InlineCode> returns
          a scalar value. Optionally, you can provide a third argument
          as a starting value, which defaults to 0.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/13e309e1cf" />
        <h4>Modules</h4>
        <p>
          Python's core design philosophy emphasizes simplicity and
          efficiency, keeping the language small and easy to learn.
          However, many programming tasks require additional
          capabilities, which are provided through the use of modules.
          In Python, a module is a collection of code that groups
          together functions, classes, and variables according to
          functionality. Modules serve as a way to organize your code
          into reusable and logically grouped components. They are
          essential for managing complexity in larger programs and
          promoting code reuse across projects. Python comes with an
          extensive standard library of modules that provide pre-built
          functionality for various tasks. We will explore some of the
          most commonly used standard modules distributed with Python
          later on. In addition to the standard modules, there are
          many additional packages available for installation, such as
          those from PyPi or Conda. However, exercise caution when
          installing third-party packages to ensure their
          trustworthiness and compatibility with your project.
        </p>
        <p>
          To create a module, you simply save your Python code in a
          separate <InlineCode>.py</InlineCode> file with a
          descriptive name, such as{' '}
          <InlineCode>my_module.py</InlineCode>. This file should
          contain functions, classes, or variables that you want to
          reuse in other parts of your program or in other programs.
          As discussed earlier in the context of variable scoping,
          Python identifies which variable or function you are
          referring to by resolving its name in a namespace. To use
          functions, classes, or variables from a module in your
          Python program, you need to import the module. Python
          provides three ways to do this. The simplest way to access a
          module is to provide the module's name to the{' '}
          <InlineCode>import</InlineCode> statement. For example, to
          import a module named <InlineCode>my_module</InlineCode>,
          you'd use <InlineCode>import my_module</InlineCode>. It
          makes all the functions, classes, and variables in the
          module available under the{' '}
          <InlineCode>my_module</InlineCode> namespace. If you only
          need specific items from a module, you can import them
          directly. This way, you can use{' '}
          <InlineCode>function_name</InlineCode> without needing to
          prefix it with <InlineCode>module_name</InlineCode>. For
          instance,{' '}
          <InlineCode>from my_module import my_function</InlineCode>.
          While this approach is slightly more efficient than
          importing an entire module, it eliminates the explicit
          connection between the imported function and the module it
          was imported from. You also need to list every function you
          want to use in the import statement. You can also import all
          of the objects from a module into the local namespace by
          using an asterisk after the <InlineCode>import</InlineCode>{' '}
          statement, e.g.{' '}
          <InlineCode>from my_module import *</InlineCode>. Since this
          may override existing objects and even built-in objects,
          imports of whole modules should be used carefully. To give a
          module a shorter name, you can use the{' '}
          <InlineCode>as</InlineCode> keyword to create an alias. This
          is useful when working with modules with long names or to
          avoid naming conflicts. For example,{' '}
          <InlineCode>import my_long_module_name as mlm</InlineCode>.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/d10dacf79a" />
        <p>
          When you import a module, Python searches for it in a
          specific order. First, it checks the current directory where
          your script is located. Then, it looks in the built-in
          modules. Finally, it searches in directories listed in the{' '}
          <InlineCode>sys.path</InlineCode> variable. Understanding
          this order can help you manage your module imports
          effectively.
        </p>
        <p>
          When the Python interpreter reads a source file, it executes
          all the code found in that file. Consequently, when you{' '}
          <InlineCode>import</InlineCode> a module into a Python
          program, the contents of the module are executed. This
          behavior can lead to unintended consequences when users
          accidentally invoke scripts they didn't intend to. To
          address this issue, Python provides a built-in variable
          called <InlineCode>__name__</InlineCode>. This variable has
          a special role in module execution. When a module is
          imported, the <InlineCode>__name__</InlineCode> variable is
          set to the name of that module. However, when a program is
          executed directly (as opposed to being imported as a
          module), the <InlineCode>__name__</InlineCode> variable is
          set to the value
          <InlineCode>"__main__"</InlineCode>. This concept forms the
          basis for the commonly seen{' '}
          <InlineCode>if __name__ == "__main__":</InlineCode>{' '}
          statement in Python code. It allows you to differentiate
          between code that should run only when the script is
          executed directly and code that should be available for
          import as a module. By using the{' '}
          <InlineCode>if __name__ == "__main__":</InlineCode>{' '}
          construct, you can conditionally execute specific code
          blocks only when the script is run directly. This is
          particularly useful for creating reusable modules that can
          be both imported and executed independently.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/8f73e996b1" />
        <h3 id="object-oriented-programming">
          Object-Oriented Programming
        </h3>
        <p>
          Object-Oriented Programming (OOP) is a programming paradigm
          that uses objects and classes to structure code. In Python,
          everything is an object, and classes are the blueprints for
          creating objects. A class defines the attributes (data) and
          methods (functions) that objects of that class will have.
          OOP promotes the organization of code into reusable,
          self-contained units, making it easier to manage and
          maintain complex systems.
        </p>
        <p>
          In Python, you define a class using the{' '}
          <InlineCode>class</InlineCode> keyword followed by the class
          name. The class definition typically contains attributes and
          methods. Attributes are variables that store data, while
          methods are functions that define the behaviors of the
          objects created from the class. To use a class, you create
          objects or instances of that class. This process is known as
          instantiation. Each object is a unique instance of the
          class, with its own set of attributes and the ability to
          call methods defined in the class.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/7e517d2f0f" />
        <p>
          In Python, the <InlineCode>self</InlineCode> parameter is a
          reference to the instance of the class. It is the first
          parameter in all instance methods and allows you to access
          and modify attributes and call other methods within the
          class. While you can name this parameter differently, it's a
          convention to use <InlineCode>self</InlineCode>.
        </p>
        <h4>Operator Overloading</h4>
        <p>
          Besides creating methods on our own, we can change the way
          many familiar operators work by a technique known as
          operator overloading. Special methods, whose names begin and
          end with double underscores, can be defined to “intercept”
          many common operators, allowing you to redefine what such
          operators as <InlineCode>print</InlineCode>,{' '}
          <InlineCode>+</InlineCode>, and <InlineCode>*</InlineCode>,
          or functions like <InlineCode>len</InlineCode>, will do when
          they're applied to the objects you create. One of the most
          important operator overloading methods is the{' '}
          <InlineCode>__init__</InlineCode> method.
        </p>
        <p>
          The <InlineCode>__init__</InlineCode> method is a special
          method in Python classes, also known as the constructor. It
          gets called when you create a new instance of the class and
          allows you to initialize attributes.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/645f08ebd4" />
        <p>
          The <InlineCode>__str__</InlineCode> method is called
          through the print statement. The{' '}
          <InlineCode>__repr__</InlineCode> method is called when an
          object's name is typed in the interpreter. The following
          table lists some of the more commonly used methods for
          overloading.
          <Table
            columns={['Method', 'Description']}
            data={[
              [
                '__str__',
                'Converts an object to a string for printing.',
              ],
              [
                '__repr__',
                'Returns a string representation of the object for debugging.',
              ],
              ['__len__', 'Returns the length of an object.'],
              [
                '__add__',
                'Defines behavior for the addition operation.',
              ],
              [
                '__sub__',
                'Defines behavior for the subtraction operation.',
              ],
              [
                '__mul__',
                'Defines behavior for the multiplication operation.',
              ],
              [
                '__truediv__',
                'Defines behavior for the true division operation.',
              ],
              [
                '__floordiv__',
                'Defines behavior for the floor division operation.',
              ],
              [
                '__mod__',
                'Defines behavior for the modulus operation.',
              ],
              [
                '__eq__',
                'Defines behavior for the equality comparison.',
              ],
              [
                '__ne__',
                'Defines behavior for the inequality comparison.',
              ],
              [
                '__lt__',
                'Defines behavior for the less-than comparison.',
              ],
              [
                '__le__',
                'Defines behavior for the less-than-or-equal comparison.',
              ],
              [
                '__gt__',
                'Defines behavior for the greater-than comparison.',
              ],
              [
                '__ge__',
                'Defines behavior for the greater-than-or-equal comparison.',
              ],
            ]}
          />
        </p>
        <p>
          In addition, you can define what happens when your object is
          iterated over by means of the for statement by defining an
          <InlineCode>__iter__</InlineCode> method that simply returns
          the object itself and providing a{' '}
          <InlineCode>next</InlineCode> method which will be called
          for each iteration. Inside the <InlineCode>next</InlineCode>{' '}
          method, you need to raise a{' '}
          <InlineCode>StopIteration</InlineCode> exception when no
          more items are available.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/d5e28c7b94" />
        <h4>Private Attributes</h4>
        <p>
          In many object-oriented languages, certain attributes can be
          declared as private, making it impossible for users of a
          class to directly view or modify their values. The designer
          of the class then provides methods to control the ways in
          which these attributes can be manipulated. While Python
          classes don't have true private attributes, if an attribute
          name begins with two underscores, the Python interpreter
          internally modifies the attribute's name, so that references
          to the attribute will not be resolved. The attribute name is
          still accessible, but this convention indicates that an
          attribute should not directly be manipulated and gives you
          more control over the way users of your class will
          manipulate those attributes.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9c5ba9d345" />
        <p>
          In Python, there is the concept of "protected" attributes,
          which is not enforced by the language itself but is a strong
          convention and best practice within the Python community.
          While an attribute with a single leading underscore, like{' '}
          <InlineCode>_protected_var</InlineCode>, doesn't have any
          special meaning to the Python interpreter, it carries a
          significant message to developers. It signals that this
          attribute is intended for internal use within a class and
          should not be accessed or modified directly from outside the
          class. Think of "protected" attributes as a way to
          communicate within the Python code itself. It indicates
          that, while technically accessible, this attribute is part
          of the class's internal workings and not meant to be part of
          the class's public interface. This convention helps improve
          code organization, maintainability, and readability. By
          encouraging developers to use getter and setter methods to
          interact with "protected" attributes, it promotes the
          principles of encapsulation and information hiding. It
          separates the internal details of a class from the outside
          world, making it easier to understand and maintain the code.
        </p>
        <h4>Class and Instance Variables</h4>
        <p>
          Class variables are shared by all instances of a class and
          are defined within the class but outside any method.
          Instance variables are specific to each instance of a class
          and are typically defined within the{' '}
          <InlineCode>__init__</InlineCode> method.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/cfe4be0a90" />
        <h4>Class Methods and Static Methods</h4>
        <p>
          Class methods are methods that are bound to the class and
          not the instance. They can access and modify class-level
          attributes. Static methods are similar but don't have access
          to instance-specific or class-specific attributes.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/8782124be5" />
        <h4>Inheritance</h4>
        <p>
          Inheritance is a fundamental concept in OOP that allows you
          to create new classes based on existing ones. The new class
          (subclass or derived class) inherits attributes and methods
          from the parent class (base class or superclass). You can
          also override or extend inherited methods and attributes in
          the subclass.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/4bc092e290" />
        <h4>Encapsulation</h4>
        <p>
          Encapsulation is the practice of bundling data (attributes)
          and the methods (functions) that operate on that data into a
          single unit (a class). It helps hide the internal details of
          how an object works, providing an interface for interacting
          with the object while protecting its integrity.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/f6c4270aab" />
        <h4>Polymorphism</h4>
        <p>
          Polymorphism is the ability of different objects to respond
          to the same method or attribute in a way that is appropriate
          for their individual types. Python supports polymorphism
          through method overriding and method overloading. The
          example provided for inheritance also demonstrates
          polymorphism since the subclasses{' '}
          <InlineCode>Cat</InlineCode> and{' '}
          <InlineCode>Dog</InlineCode> override the{' '}
          <InlineCode>speak</InlineCode> method of the{' '}
          <InlineCode>Animal</InlineCode> base class.
        </p>
        <h3 id="debugging-error-handling-and-unit-testing">
          Debugging, Error Handling and Unit Testing
        </h3>
        <h4>Debugging</h4>
        <p>
          Debugging is the process of identifying and fixing errors or
          bugs in your code. Python provides several tools and
          techniques to help you diagnose and resolve issues in your
          programs. Effective debugging is an essential skill for
          every programmer, as it can save time and frustration during
          the development process.
        </p>
        <h5>Errors and Exceptions</h5>
        <p>
          A Python program terminates as soon as it encounters an
          error. In Python, an error can be a syntax error or an
          exception. While for simple programs it might be sufficient
          to just fail, we often need proper error handling to prevent
          that an error crashes whole programs or applications.
        </p>
        <p>
          A syntax error occurs when the parser detects an incorrect
          statement. Let's take a look at the following example:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c8a28eb04e" />
        <p>
          In this example, there was one bracket too many. Remove it
          and run the code again. This time, there is an exception.
          This type of error occurs when syntactically correct Python
          code results in an error. Python provides details about the
          type of exception encountered. In this case, it was a{' '}
          <InlineCode>ZeroDivisionError</InlineCode>. Python provides
          various built-in exceptions and also offers the possibility
          to create self-defined exceptions. To throw an exception,
          you can use the <InlineCode>raise</InlineCode> statement.
        </p>
        <p>
          While exceptions are great, we still need to handle them
          because just throwing exceptions still results in programs
          terminating. To catch and handle exceptions,{' '}
          <InlineCode>try</InlineCode> and{' '}
          <InlineCode>except</InlineCode> are used in Python. The
          statement inside the <InlineCode>try</InlineCode> block is
          executed and if an exception occurs, the code inside the{' '}
          <InlineCode>except</InlineCode> statement is executed.
          Catching <InlineCode>Exception</InlineCode> hides all
          errors, even those which are completely unexpected. This is
          why you should avoid bare <InlineCode>except</InlineCode>{' '}
          clauses in your Python programs. Instead, you'll want to
          refer to specific exception classes you want to catch and
          handle. In Python, using the <InlineCode>else</InlineCode>{' '}
          statement, you can instruct a program to execute a certain
          block of code only in the absence of exceptions. Everything
          in the <InlineCode>finally</InlineCode> clause will be
          executed regardless if you encounter an exception somewhere
          in the <InlineCode>try</InlineCode> or{' '}
          <InlineCode>else</InlineCode> clauses.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/8df821aa1e" />
        <p>
          Instead of waiting until a program crashes, you can also use
          assertions to prevent errors early on. Assertions are a
          technique of defensive programming. By asserting that a
          certain condition is met, the program is only continued if
          the condition turns out to be <InlineCode>True</InlineCode>.
          Otherwise, we can have the program throw an{' '}
          <InlineCode>AssertionError</InlineCode> exception.
        </p>
        <p>
          There is a third type of errors, namely logical errors, also
          known as bugs. Logical errors occur when your code does not
          produce the expected output or behaves incorrectly. These
          errors can be challenging to identify because Python does
          not raise an error. Instead, the program executes, but the
          results are incorrect.
        </p>
        <p>
          Python offers several debugging tools and techniques to help
          you identify and fix errors. The simplest debugging
          technique is to add <InlineCode>print</InlineCode>{' '}
          statements in your code to display the values of variables
          and the flow of execution. This can help you understand what
          your code is doing and identify where issues may arise.
          Alternatively, you can utilize logging as an effective
          method to gather program information, not only in the event
          of an error. Logging will be discussed when talking about
          the Python standard library. Python also includes an
          interactive debugger called <InlineCode>pdb</InlineCode>{' '}
          (Python Debugger). You can insert breakpoints in your code
          using <InlineCode>pdb.set_trace()</InlineCode> and then run
          your script with the <InlineCode>-m pdb</InlineCode> option.
          This launches an interactive debugging session where you can
          inspect variables, step through code, and evaluate
          expressions. Many Python IDEs, such as PyCharm or Visual
          Studio Code, provide built-in debugging features. These
          tools offer a user-friendly interface for setting
          breakpoints, inspecting variables, and navigating through
          your code during debugging.
        </p>
        <h5>Common Debugging Practices</h5>
        <p>
          When debugging in Python, consider the following best
          practices:
          <ol>
            <li>
              Begin by isolating the portion of code where the error
              occurs. Comment out unrelated code to narrow down the
              issue.
            </li>
            <li>
              Ensure you can reproduce the error consistently.
              Understanding the conditions that trigger the error is
              crucial for debugging.
            </li>
            <li>
              Insert <InlineCode>print</InlineCode> or logging
              statements strategically to print the values of
              variables and intermediate results. This helps you track
              the flow of execution and identify unexpected values.
            </li>
            <li>
              Verify that the data types of variables match your
              expectations. Python is dynamically typed, so data type
              errors can occur if you assume the wrong type.
            </li>
            <li>
              Check the official Python documentation and the
              documentations of any libraries you are using to ensure
              you are using functions and methods correctly.
            </li>
            <li>
              Pay attention to error messages and traceback
              information. Python's error messages often provide clues
              about the cause of the problem and the location in your
              code where it occurred.
            </li>
          </ol>
        </p>
        <h5>Fixing Bugs</h5>
        <p>
          Once you identify a bug, you may follow these steps to fix
          it:
          <ol>
            <li>
              Understand the root cause of the problem by reviewing
              the code and considering the inputs and logic.
            </li>
            <li>
              Modify the code to correct the issue. Be cautious not to
              introduce new errors while fixing the current one.
            </li>
            <li>
              Test your code to ensure that the bug is resolved and
              that the fix does not cause side effects in other parts
              of the program. It is considered a best practice when
              you are debugging your code to first write a new test
              pinpointing the bug.
            </li>
            <li>
              If you're working in a team or on a larger project,
              document your changes to help others understand the
              modifications and the reasons behind them.
            </li>
          </ol>
        </p>
        <h4>Unit Testing</h4>
        <p>
          Testing your code is very important. It does not only allow
          you to ensure that your program still works correctly after
          you made changes to your code but also helps to isolate
          errors. Unit testing is a method for testing software that
          looks at the smallest testable pieces of code, called units,
          which are tested for correct operation. By doing unit
          testing, we can verify that each part of the code, including
          helper functions that may not be exposed to the user, works
          correctly and as intended.
        </p>
        <p>
          In Python, there are two popular unit testing frameworks:
          the built-in <InlineCode>unittest</InlineCode> module (often
          referred to as the PyUnit framework) and the{' '}
          <ExternalLink href="https://pytest.org">
            pytest
          </ExternalLink>{' '}
          framework.
        </p>
        <p>
          The <InlineCode>unittest</InlineCode> module is included in
          the Python standard library. Creating test cases is
          accomplished by subclassing{' '}
          <InlineCode>unittest.TestCase</InlineCode>. Here's a simple
          example:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/48f3220624" />
        <p>
          In larger projects, you may have multiple test classes, each
          containing several test methods. To organize and run these
          tests efficiently, you can create test cases and test
          suites. A test case is a collection of related test methods
          within a test class. It represents a specific aspect of
          functionality or behavior to be tested. A test suite is a
          collection of test cases. It allows you to group related
          tests together. Python's <InlineCode>unittest</InlineCode>{' '}
          framework provides the <InlineCode>TestLoader</InlineCode>{' '}
          and <InlineCode>TestSuite</InlineCode> classes to help
          create and organize test suites.
        </p>
        <p>
          Test fixtures are preconditions and postconditions that are
          established before and after running a test. In Python, you
          can use <InlineCode>setUp</InlineCode> and{' '}
          <InlineCode>tearDown</InlineCode> methods within your test
          class to set up and clean up resources required for testing.
          These methods run before and after each test method,
          ensuring a consistent test environment. In some cases, you
          may want to isolate the code under test by replacing
          external dependencies, such as databases or APIs, with mock
          objects or test doubles. Python's{' '}
          <InlineCode>unittest.mock</InlineCode> module provides tools
          for creating and using mock objects in your tests. The
          unittest framework also supports test discovery, which
          allows you to automatically discover and run tests within
          your project.
        </p>
        <p>
          Pytest is an alternative to Python's standard unittest
          module, which can be installed using{' '}
          <InlineCode>pip</InlineCode>. Despite being a fully-featured
          and extensible test tool, it boasts a simple syntax.
          Creating a test suite is as easy as writing a module with a
          couple of functions. Pytest offers a wide range of features
          for test discovery, fixtures, parameterized testing, and
          plugins.
        </p>
        <p>
          In real-world software development, unit tests are often
          integrated into a Continuous Integration (CI) pipeline. CI
          systems automatically run unit tests whenever code changes
          are pushed to version control repositories. This practice
          helps identify and address issues early in the development
          process. Tools like <InlineCode>coverage.py</InlineCode> can
          help you determine which parts of your code are covered by
          your unit tests. Achieving high test coverage is a common
          goal in software testing to ensure that all critical paths
          are tested.
        </p>
        <p>
          In summary, debugging, error handling, and unit testing are
          crucial aspects of writing robust and reliable Python code.
          By mastering these practices, you can create software that
          is more stable, maintainable, and resistant to bugs.
        </p>
        <h3 id="standard-library">Standard Library</h3>
        <p>
          Python's standard library is exceptionally comprehensive,
          offering a wide array of tools and functionalities. It
          consists of built-in modules, some of which are implemented
          in C, granting Python programmers access to system-level
          operations like file input/output, which would otherwise be
          beyond their reach. Additionally, Python-written modules in
          the standard library provide standardized solutions to a
          multitude of common programming challenges. Many of these
          modules are intentionally designed to foster and improve the
          portability of Python programs, abstracting away
          platform-specific details and offering platform-neutral
          APIs.
        </p>
        <p>
          In addition to the standard library, there exists an active
          collection of hundreds of thousands of software components.
          These range from individual programs and modules to
          fully-fledged packages and comprehensive application
          development frameworks. This extensive repository of
          third-party packages can be found for example on the{' '}
          <ExternalLink href="https://pypi.org/">
            Python Package Index (PyPi)
          </ExternalLink>
          .
        </p>
        <p>
          In the following sections, we will take a look at some of
          the most commonly used modules from Python's standard
          library, equipping you with essential tools and knowledge
          for your further journey in Python programming.
        </p>
        <h4>Argparse</h4>
        <p>
          <InlineCode>argparse</InlineCode> is a Python module for
          parsing command-line arguments and options in a structured
          and user-friendly manner. It simplifies the process of
          taking input from the command line and is particularly
          useful when creating Python scripts or programs that require
          configuration or customization via the command line.
          <LazyIframe src="https://trinket.io/embed/python/b26f37c61d" />
          When running this script from the command line, you can
          specify the <InlineCode>input_file</InlineCode> and
          optionally the <InlineCode>--output</InlineCode> file as
          follows:
          <CodeBlock
            text={'python main.py input.txt --output output.txt'}
            language="bash"
            showLineNumbers={false}
            theme={dracula}
          />
        </p>
        <h4>File I/O</h4>
        <p>
          Python's standard library includes modules for performing
          file input and output operations. The primary module for
          this purpose is <InlineCode>open()</InlineCode>, which
          allows you to open files for reading, writing, or both. You
          can also use the <InlineCode>with</InlineCode> statement to
          ensure that files are properly closed after usage.
        </p>
        <h5>Opening a File</h5>
        <p>
          The <InlineCode>open()</InlineCode> function takes two
          arguments: the file name (including the path) and the mode
          in which you want to open the file. Common modes include "r"
          for read mode (default), "w" for write mode and "a" for
          append mode.
        </p>
        <h5>Closing a File</h5>
        <p>
          It's important to close a file after you're done with it to
          release system resources and ensure that changes are saved.
          You can use the <InlineCode>close()</InlineCode> method or
          work with files using the <InlineCode>with</InlineCode>{' '}
          statement, which automatically closes the file when you exit
          the block.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1d7641dcc5" />
        <h5>Reading from a File</h5>
        <p>
          Once you've opened a file for reading, you can use various
          methods to read its content.
          <LazyIframe src="https://trinket.io/embed/python/fab1ffc087" />
        </p>
        <h5>Writing to a File</h5>
        <p>
          When a file is opened in write or append mode, you can use
          methods like <InlineCode>write()</InlineCode> to add content
          to the file.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ff6855175a" />
        <h5>Exception Handling</h5>
        <p>
          When working with files, it's a good practice to handle
          exceptions, especially when opening, reading, or writing
          files, as various errors can occur (e.g., the file might not
          exist, you may not have permission to read or write it).
        </p>
        <h4>Logging</h4>
        <p>
          Logging is an essential part of software development that
          allows you to record messages, warnings, errors, and other
          information about the execution of your Python programs. The
          Python standard library provides a built-in module called{' '}
          <InlineCode>logging</InlineCode> for handling logging
          operations.
        </p>
        <p>
          To use the <InlineCode>logging</InlineCode> module, you need
          to import it at the beginning of your script. Before you
          start logging messages, you can configure the logging system
          according to your needs. This includes specifying the
          logging level, setting a format for log messages, and
          defining where the log messages should be directed. Once
          you've configured logging, you can start logging messages
          using various log levels. By default, log messages of
          "WARNING" level and above are displayed on the console. You
          can control the behavior of log messages, such as where they
          are displayed and at what level, by configuring loggers,
          handlers, and formatters. For example, you can send log
          messages to multiple destinations, filter them, or format
          them differently.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/463b519c80" />
        <h4>Math</h4>
        <p>
          Python's <InlineCode>math</InlineCode> library is a built-in
          module that provides a wide range of mathematical functions
          and constants for performing various mathematical
          operations. You can use the <InlineCode>math</InlineCode>{' '}
          module to work with mathematical calculations and functions
          in your Python programs. Let's take a look at some examples.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/b8be33ca00" />
        <h4>OS</h4>
        <p>
          The <InlineCode>os</InlineCode> module in Python is a
          built-in library that provides functions for interacting
          with the operating system, allowing you to perform various
          tasks related to file and directory manipulation, working
          with file paths in a platform-independent way, environment
          variables, process management, and more.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/fc608d4da4" />
        <p>
          When working with the <InlineCode>os</InlineCode> module,
          it's essential to handle exceptions, especially when
          performing file and directory operations. Various errors can
          occur, such as files not existing, insufficient permissions,
          or incorrect paths.
        </p>
        <h4>Pathlib</h4>
        <p>
          The <InlineCode>pathlib</InlineCode> module in Python is a
          powerful and object-oriented library for working with file
          system paths and files. Introduced in Python 3.4,{' '}
          <InlineCode>pathlib</InlineCode> offers a more intuitive and
          platform-independent way to manipulate paths and perform
          file and directory operations. The central concept of{' '}
          <InlineCode>pathlib</InlineCode> is the{' '}
          <InlineCode>Path</InlineCode> object. You create a{' '}
          <InlineCode>Path</InlineCode> object by passing a path
          string to its constructor.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/2a1147eeae" />
        <h4>Regex</h4>
        <p>
          The <InlineCode>re</InlineCode> module in Python, also known
          as the "regex" module, allows you to work with regular
          expressions. Regular expressions are powerful patterns that
          help you search for and manipulate text data based on
          specific patterns.
        </p>
        <p>
          Let's look at an example to understand why this is useful.
          Assume, we might want to validate an email address.{' '}
        </p>
        <LazyIframe src="https://trinket.io/embed/python/82d8a6c4f9" />
        <p>
          Regular expressions consist of patterns that describe
          specific sequences of characters. Some common elements used
          in regular expressions are:
          <ul>
            <li>
              Literal Characters: Characters like letters and digits
              match themselves. For example, the pattern "abc" matches
              the string "abc" exactly.
            </li>
            <li>
              Dot: The dot "." matches any single character except a
              newline. For example, the pattern "a.c" matches "abc",
              "adc", and so on.
            </li>
            <li>
              Character Classes: Square brackets{' '}
              <InlineCode>[...]</InlineCode> define a character class,
              and the pattern matches any single character that is in
              the class. For example, <InlineCode>[aeiou]</InlineCode>{' '}
              matches any vowel, and <InlineCode>[0-9]</InlineCode>{' '}
              matches any digit.
            </li>
            <li>
              Caret and Dollar: The caret <InlineCode>^</InlineCode>{' '}
              matches the start of a line or string, and the dollar{' '}
              <InlineCode>$</InlineCode> matches the end of a line or
              string. For example, <InlineCode>^abc</InlineCode>{' '}
              matches if "abc" is at the start of a line.
            </li>
            <li>
              Quantifiers: Quantifiers modify the number of times a
              pattern is matched.
              <ul>
                <li>*: Matches zero or more occurrences.</li>
                <li>+: Matches one or more occurrences.</li>
                <li>?: Matches zero or one occurrence.</li>
                <li>&#123;n&#125;: Matches exactly n occurrences.</li>
                <li>
                  &#123;n, m&#125;: Matches between "n" and "m"
                  occurrences.
                </li>
              </ul>
            </li>
          </ul>
        </p>
        <p>
          The <InlineCode>re.search(pattern, string)</InlineCode>{' '}
          function is used to search for the first occurrence of a
          pattern in a string. It returns a match object if a match is
          found or <InlineCode>None</InlineCode> if no match is found.
          You can use the <InlineCode>.group()</InlineCode> method of
          the match object to extract the matched text.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/bfb522c312" />
        <p>
          The <InlineCode>re.findall(pattern, string)</InlineCode>{' '}
          function returns a list of all non-overlapping matches of a
          pattern in a string. It returns an empty list if no matches
          are found.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/f401bbca91" />
        <p>
          The{' '}
          <InlineCode>
            re.sub(pattern, replacement, string)
          </InlineCode>{' '}
          function replaces all occurrences of a pattern in a string
          with the specified replacement.
        </p>
        <p>
          You can also compile regular expressions using{' '}
          <InlineCode>re.compile(pattern)</InlineCode> to improve
          performance if you plan to use the same pattern multiple
          times.
        </p>
        <p>
          Let's go back to our previous email example. Thankfully,
          common patterns have been built into regular expressions by
          hard-working programmers. Notice that{' '}
          <InlineCode>\w</InlineCode> is the same as{' '}
          <InlineCode>[a-zA-Z0-9_]</InlineCode>. You may want to test
          different emails for validity and figure out how and why it
          works. There are also great (visual) regex testers like{' '}
          <ExternalLink href="https://www.debuggex.com/">
            Debuggex
          </ExternalLink>{' '}
          which can help you.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/71bdfcacce" />
        <h4>Sys</h4>
        <p>
          The <InlineCode>sys</InlineCode> module in Python is a
          built-in module that provides access to system-specific
          parameters and functions. It is often used to interact with
          the Python runtime environment and system-related
          functionality.
        </p>
        <p>
          The <InlineCode>sys.exit()</InlineCode> function is used to
          exit a Python script with an optional exit status code. It
          allows you to terminate the script programmatically, and you
          can specify an exit status to indicate the success or
          failure of the script (0 for success, non-zero for failure):
        </p>
        <p>
          The <InlineCode>sys</InlineCode> module also provides access
          to the standard input, standard output, and standard error
          streams:
          <ul>
            <li>
              <InlineCode>sys.stdin</InlineCode>: Represents the
              standard input stream. You can use it to read input from
              the user or a file.
            </li>
            <li>
              <InlineCode>sys.stdout</InlineCode>: Represents the
              standard output stream. You can use it to print output
              to the console or redirect it to a file.
            </li>
            <li>
              <InlineCode>sys.stderr</InlineCode>: Represents the
              standard error stream. You can use it to print error
              messages to the console or redirect them to a file.
            </li>
          </ul>
        </p>
        <p>
          The <InlineCode>sys</InlineCode> module provides information
          about the Python runtime environment and the underlying
          operating system through various attributes:
          <ul>
            <li>
              <InlineCode>sys.version</InlineCode>: Returns the Python
              version string.
            </li>
            <li>
              <InlineCode>sys.version_info</InlineCode>: Returns a
              tuple containing the major, minor, micro, release level,
              and serial version components.
            </li>
            <li>
              <InlineCode>sys.platform</InlineCode>: Returns a string
              indicating the platform where Python is running (e.g.,
              "win32" for Windows, "linux" for Linux).
            </li>
          </ul>
        </p>
        <p>
          The <InlineCode>sys.path</InlineCode> contains a list of
          directories that Python searches when importing modules. You
          can modify this list to add custom directories to the module
          search path:{' '}
          <InlineCode>
            sys.path.append("/path/to/my_module_directory")
          </InlineCode>
          .
        </p>
        <h3 id="misc">Misc</h3>
        <p>
          Follows soon...stay tuned! Suggestions are always welcome.
        </p>
        <div style={{ textAlign: 'center' }}>
          <a
            rel="license"
            href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
          >
            <img
              alt="Creative Commons License"
              style={{ borderWidth: 0 }}
              src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"
            />
          </a>
        </div>
        This work is licensed under a{' '}
        <a
          rel="license"
          href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
        >
          Creative Commons Attribution-NonCommercial-ShareAlike 4.0
          International License
        </a>
        .
      </Article>
    </main>
  );
};

export { IntroductionToPython };
