import React from 'react';

import { CodeBlock, dracula } from 'react-code-blocks';

import { Article } from '../components/articles/Article';
import { ExternalLink } from '../components/articles/ExternalLink';
import { InlineCode } from '../components/articles/InlineCode';
import { LazyIframe } from '../components/articles/LazyIframe';

const IntroductionToPython = () => {
  return (
    <main className="main">
      <Article
        title={'Introduction To Python'}
        subtitle={'Yet Another Python Guide?'}
      >
        <p>
          The following introduction to Python serves as additional,
          supplementary material to the lecture of the same name.
          Since it is a comprehensive, stand-alone introduction, it
          can also be used to learn the basics of Python on your own.
          The concept of this introduction is inspired by the
          JavaScript reference in the{' '}
          <ExternalLink href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">
            MDN Web Docs
          </ExternalLink>{' '}
          which I really like because it provides good explanations
          along with code sandboxes that allow you to play directly
          with the code while learning. I would encourage you to do
          exactly that.
        </p>
        <p>The lecture slides are also available here.</p>
        <h3 id="what-is-python-and-why-you-should-learn-it">
          What Is Python and Why You Should Learn It
        </h3>
        <p>
          <ExternalLink href="https://www.python.org/">
            Python
          </ExternalLink>{' '}
          is a high-level programming language created by Guido van
          Rossum. It was released in 1991. Although images of snakes
          are often associated with Python, the name is actually
          derived from Guido van Rossum's favorite TV show, "Monty
          Python's Flying Circus". Python is an object-oriented
          programming language which is available on a wide variety of
          systems and can be used for a lot of different applications.
          The current version is Python 3, which will be the focus of
          the following explanations. Python is designed to be a
          beginner-friendly yet powerful programming language. In
          recent years, Python has gained increasing popularity,
          especially due to well-known and robust frameworks designed
          for scientific computing, artificial intelligence, and data
          science. Examples of such frameworks include{' '}
          <ExternalLink href="https://numpy.org/">Numpy</ExternalLink>
          ,{' '}
          <ExternalLink href="https://pandas.pydata.org/">
            Pandas
          </ExternalLink>
          ,{' '}
          <ExternalLink href="https://pytorch.org/">
            PyTorch
          </ExternalLink>{' '}
          or{' '}
          <ExternalLink href="https://www.tensorflow.org/">
            TensorFlow
          </ExternalLink>
          . Python is also commonly used for automation, prototyping,
          and even web development.
        </p>
        <p>
          Unlike many other programming languages, Python statements
          do not require termination with a special character. The
          Python interpreter identifies the end of a statement through
          the presence of a newline, generated by pressing the
          "Return" key on the keyboard. We will delve into multi-line
          statements in subsequent sections. Another crucial point to
          note is that Python relies on indentation instead of
          delimiters like curly braces. While the specific amount of
          indentation doesn't hold significance, it must remain
          consistent within a given depth of a loop or conditional
          statement. Additionally, statements that are not intended to
          be indented must start from the first column. However,
          adhering to the convention outlined in{' '}
          <ExternalLink href="https://peps.python.org/pep-0008/">
            PEP 8
          </ExternalLink>
          , it is recommended to use 4 spaces for indentation, a
          practice we'll explore further in upcoming discussions.
        </p>

        <h3 id="how-to-invoke-python-code">
          How To Invoke Python Code
        </h3>
        <p>
          To get started with running Python code on your computer,
          you'll need to install a{' '}
          <ExternalLink href="https://www.python.org/downloads/">
            Python interpreter
          </ExternalLink>{' '}
          which is available for Windows, Linux and Mac OS.
          Alternatively, you can also use{' '}
          <ExternalLink href="https://docs.conda.io/en/latest/">
            Conda
          </ExternalLink>{' '}
          (or one of its variations like MicroConda or Mamba). We'll
          talk more about these options when we discuss virtual
          environments in a moment.
        </p>
        <p>
          Once Python is installed on your system, there are two main
          ways to start using it. The first method is by opening your
          shell or command prompt and typing "python". This will
          launch the Python interpreter, and you'll see something like
          this:
          <CodeBlock
            text={`Python 3.11.3 (main, Jun  5 2023, 09:32:32) [GCC 13.1.1 20230429] on linux\nType "help", "copyright", "credits" or "license" for more information.\n>>>`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          The three greater-than signs (&gt;&gt;&gt;) are prompts that
          indicate you can type your commands below them. When you
          press "Enter", Python will execute your command. If you type
          a command like Python's <InlineCode>print()</InlineCode>,
          the result will show up on the screen, like this:
          <CodeBlock
            text={`>>> print("Hello World")\nHello World`}
            language={'bash'}
            showLineNumbers={false}
            theme={dracula}
          />
          For longer programs, you can use your preferred text editor
          or Integrated Development Environment (IDE) to write your
          Python code. The common file extension for Python files is
          ".py". To run your program, type "python" followed by the
          name or path of your file. Most modern IDEs also offer a
          "run" button that you can click.
        </p>
        <p>
          One of the great advantages of Python is its easy-to-use
          libraries and external packages. Since many people use
          Python, there's a wide variety of pre-built packages
          available for many different tasks. The Python Package Index
          (<ExternalLink href="https://pypi.org/">PyPI</ExternalLink>)
          is a collection of software for Python that offers numerous
          packages. You can install Python packages from PyPI using a
          package management tool called "pip".
        </p>
        <div>
          However, Python is not great at dependency management. This
          is why nearly every Python user recommends to use virtual
          environments. Virtual environments are a Python tool for
          dependency management and project isolation. They provide a
          simple solution for a lot of potential problems by helping
          you to:
          <div>
            <ul>
              <li>Resolve dependency issues</li>
              <li>Create self-contained and reproducible projects</li>
              <li>Avoid system pollution</li>
              <li>Install packages without admin rights</li>
            </ul>
          </div>
          There are various approaches to creating a virtual
          environment. One option is to use{' '}
          <ExternalLink href="https://docs.python.org/3/library/venv.html">
            venv
          </ExternalLink>
          , a built-in tool in Python. External tools like virtualenv
          or Conda are also commonly used. Conda provides an
          alternative package and environment management approach. It
          not only enables easy creation of virtual environments with
          different Python versions but also introduces an additional
          feature set. It's worth noting that Conda is a separate
          project and is unrelated to pip. It uses an alternative
          package index maintained by the Anaconda project instead of
          PyPI. Conda packages can be installed using the command
          "conda install". As an alternative,{' '}
          <ExternalLink href="https://www.docker.com/">
            Docker
          </ExternalLink>{' '}
          can also be used to create a containerized Python
          development environment. Docker allows you to package your
          Python application along with its dependencies and system
          configurations, ensuring consistency across different
          environments.
        </div>

        <h3 id="variables">Variables</h3>
        <p>
          In Python, variables are used for storing and managing data.
          Think of variables as containers that can hold values of
          various data types, such as numbers, strings, or complex
          objects. You can assign values to variables using the
          assignment operator =. There are a few variable naming rules
          and conventions in Python. Variable names can contain
          letters, numbers, and underscores. But they must start with
          a letter or an underscore. Variable names are
          case-sensitive. And you should avoid using built-in Python
          keywords as variable names.
        </p>
        <p>
          Python uses dynamic typing, which means that you can change
          the type of data stored in a variable during the program's
          execution. You can reassign a variable to hold a different
          data type without explicitly declaring its type. Dynamic
          typing provides flexibility but also requires careful
          handling of variable types to avoid unexpected behavior.
        </p>
        <p>
          Variables have different scopes, which define where in the
          code they can be accessed. In Python, there are primarily
          three levels of variable scope: global scope, local scope
          and enclosing scope. We will discuss the details when
          talking about functions.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/cf66687956" />

        <h3 id="data-types">Data Types</h3>
        <p>
          In Python, understanding data types is fundamental to
          writing effective code. Let's explore the most common data
          types and get familiar with them. They will be discussed in
          more detail in the following sections.
        </p>

        <h4>Numeric Data Types</h4>
        <p>
          Python supports four different types of numeric data, namely
          integers, long integers, floating point numbers and complex
          numbers. Floating point numbers can be specified either by
          using a decimal point or using exponential notation, e.g.
          1e-3 or 1E-3. In Python, long integers are actually what are
          sometimes called "arbitrary precision" integers which means
          that they can have as many digits as you have typed into the
          computer. In Python 3, the "L" suffix is not required
          anymore. They also have the further advantage that all
          arithmetic performed with long integers does not have
          limited precision like floating point numbers. However,
          while regular integer arithmetic is supported by most
          operating systems, Python has to perform all its own long
          integer arithmetic. This, using (many) long integers, will
          slow your programs down. Complex numbers can be entered into
          Python using either the `complex`function or by denoting the
          complex number as the real portion followed by a plus sign
          and the imaginary part with a trailing uppercase or
          lowercase "J". There must be no spaces between the imaginary
          part and the "J". Both components are stored as floating
          point numbers.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0a86a4a000" />

        <h4>Strings</h4>
        <p>
          Strings are collections of characters that represent
          arbitrary text in Python code. They can be created by
          enclosing text in single quotes, double quotes, or triple
          quotes (which allow spanning multiple lines). Inside
          strings, special character sequences starting with a
          backslash are interpreted uniquely. Single backslashes can
          also act as continuation characters, similar to using triple
          quotes. To include an actual backslash in a string, you can
          either use two backslashes or employ raw strings by
          prefixing the opening quotation mark with "r".
        </p>
        <p>
          Unicode strings, which use 16 bits to store characters
          instead of 8 bits used by normal strings, can be created by
          prefixing the opening quote character with "u". Arbitrary
          Unicode characters can be specified using "\u" inside a
          string. Combining a Unicode string with a regular string
          results in a Unicode string.
        </p>
        <h5>String Operations</h5>
        <p>
          The following sections describe some of the most important
          operations available for working with strings.
        </p>
        <h6>Concatenation</h6>
        <p>
          Strings can be concatenated using the + operator, creating a
          new string that combines the originals. Strings can be also
          concatenated with variables.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1d49685948" />
        <h6>Repetition</h6>
        <p>
          When using an asterisk (*) between a string and an integer a
          new string is created which contains the old string repeated
          by the integer value. The order of the arguments does not
          matter.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c4ad4cc54f" />
        <h6>Indexing and Slicing</h6>
        <p>
          Strings in Python support indexing and slicing. A single
          character can be extracted from a string by appending the
          index of the desired character surrounded by square
          brackets. Keep in mind that the index starts at zero in
          Python. If the value inside the brackets is less than zero,
          Python counts from the end of the string. The last character
          in a string can be for example accessed using a subscript of
          -1.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0d52f421fd" />
        <p>
          A contiguous part of a string (called a slice) can be
          extracted by using a subscript consisting of a starting
          index followed by a colon and a ending index after it.
          Notice that the slicing stop position is exclusive, i.e. the
          slicing stops one position before the second value. If a
          slice starts at the beginning of a string or continues until
          the end, the first or second index can be omitted,
          respectively. It is also possible to use variables and
          integer constants for indexing and slicing:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/81099f478b" />
        <h6>Functions and Methods</h6>
        <p>
          Python provides some useful functions and methods for
          working with strings. The <InlineCode>len()</InlineCode>{' '}
          function returns the number of characters which a string
          contains. Strings in Python are immutable objects, i.e. the
          value of a string can't be changed in place. To change the
          value of a string, a method needs to be invoked on the
          variable containing the string and the value of this
          operation needs to be reassigned to the desired variable.
          There are a bunch of string methods provided by Python. The
          <InlineCode>split()</InlineCode> and{' '}
          <InlineCode>join()</InlineCode> methods are among the most
          useful. The <InlineCode>split()</InlineCode> method returns
          a list whose elements are a character or string in the
          original string splitted at the optionally specified
          separator. If no argument is specified, one or more
          whitespace characters are used as the default separator
          character. The following table shows an overview over some
          useful string methods:
          <table>
            <tr>
              <th>Method</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>str.upper()</td>
              <td>
                Converts all characters in the string to uppercase.
              </td>
            </tr>
            <tr>
              <td>str.lower()</td>
              <td>
                Converts all characters in the string to lowercase.
              </td>
            </tr>
            <tr>
              <td>str.strip()</td>
              <td>
                Removes leading and trailing whitespace from the
                string.
              </td>
            </tr>
            <tr>
              <td>str.split()</td>
              <td>
                Splits the string into a list of substrings based on a
                delimiter.
              </td>
            </tr>
            <tr>
              <td>str.join()</td>
              <td>
                Joins a list of strings into a single string using the
                provided delimiter.
              </td>
            </tr>
            <tr>
              <td>str.replace()</td>
              <td>
                Replaces occurrences of a substring with another
                substring.
              </td>
            </tr>
            <tr>
              <td>str.find()</td>
              <td>
                Returns the index of the first occurrence of a
                substring (or -1 if not found).
              </td>
            </tr>
            <tr>
              <td>str.startswith()</td>
              <td>
                Checks if the string starts with a specified
                substring.
              </td>
            </tr>
            <tr>
              <td>str.endswith()</td>
              <td>
                Checks if the string ends with a specified substring.
              </td>
            </tr>
            <tr>
              <td>str.isalpha()</td>
              <td>
                Checks if all characters in the string are alphabetic.
              </td>
            </tr>
          </table>
        </p>
        <LazyIframe src="https://trinket.io/embed/python/c7fb7570ab" />

        <h4>Booleans</h4>
        <p>
          Booleans represent either <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode> values and are often used in
          conditional statements and logic.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/5ad99d13cc" />

        <h4>None</h4>
        <p>
          In Python, None is a special value used to indicate the
          absence of a value or to initialize variables when you don't
          have a specific value to assign. It's often employed as a
          placeholder in situations where a variable or result is
          expected but hasn't been determined yet.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/a1b65a8f51" />

        <h4>Data Structures</h4>
        <p>
          Python provides various data structures to efficiently
          organize and manipulate data. These structures help manage
          collections of data items, making it easier to work with
          different types of information. A Python list is an ordered
          collection which allows to store objects of different data
          types. A Python dictionary is an unordered collection of
          data consisting of key/value pairs. A tuple is an ordered
          collection of different data types like a list, but tuples
          are immutable, i.e. they can not be modified once they are
          created. A set is a collection of data types that is similar
          to list and tuple, but a set is not an ordered collection of
          items and can only store unique items. These data structures
          serve various purposes, and their choice depends on the
          specific requirements of your program. We will delve deeper
          into Python data structures later on.
        </p>

        <h3 id="comments">Comments</h3>
        <p>
          Comments are a crucial aspect of Python programming. They
          serve the purpose of documenting your code and providing
          context to both others who may read your code and your
          future self. Comments are lines of text that are not
          executed by the Python interpreter and are preceded by the{' '}
          <InlineCode>#</InlineCode> symbol.
        </p>
        <p>
          Single-line comments are used for brief explanations within
          your code. While Python doesn't have a specific syntax for
          multi-line comments, you can use triple-quotes (
          <InlineCode>'''</InlineCode> or <InlineCode>"""</InlineCode>
          ) to create multi-line comment blocks, although they are
          typically used for so-called docstrings (see section about
          functions).
        </p>
        <p>
          There are different opinions on how and when to comment code
          among programmers, but using meaningful variable and
          function names is considered best practive. Clear, concise
          single-line comments can be used if needed, but are often a
          sign of code smell. However, when documenting functions or
          modules for wider use or sharing, adhering to the docstring
          conventions and practices is recommended to ensure that
          others can understand and use your code effectively.
        </p>

        <h3 id="operators">Operators</h3>
        <p>
          In Python, operators are fundamental elements used to
          perform various operations on values and variables. In this
          section, we will explore different types of operators in
          Python.
        </p>
        <h4>Assigment Operators</h4>
        <p>
          One of the fundamental operations in any programming
          language is the assignment statement. It allows us to
          associate a variable name with a value, enabling us to
          manipulate our data effectively. In Python, like many other
          programming languages, the equal sign (=) is used for
          assignment. Assignment statements can be chained together to
          set multiple variables to the same value. Multiple
          assignments are also possible by using a comma-separated
          list of variables and expressions.
        </p>
        <p>
          Without diving too deep into the internal details of Python,
          there is one crucial aspect of the assignment statement
          which needs to be understood to program effectively in
          Python. When assigning values to variables, whether they are
          numbers, strings, or expressions involving such types,
          Python stores these values in memory and associates them
          with their assigned variable names. However, when making
          assignments of one variable to another, Python actually
          stores a reference to the variable. Instead of creating a
          new copy of the contents of the original variable, it stores
          information about where the original variable is stored in
          memory. When the new variable is later referenced, it refers
          back to this location to find the value of the variable. For
          scalar variables (e.g., numbers and strings), this behavior
          generally doesn't produce unexpected results since Python
          automatically updates the values of any variables referring
          to another value once it's changed. However, with mutable
          objects such as lists, changes within the list do not
          trigger this updating mechanism, which can lead to
          surprising results. If you genuinely want to make a copy of
          a list instead of merely storing a reference, you can use
          Python's <InlineCode>copy</InlineCode>module. We will
          discuss this in more detail when talking about data
          structures.
        </p>
        <p>
          In addition to the basic assignment operator (=), Python
          also provides several other assignment operators, as shown
          in the following table:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/b38470ba30" />

        <h4>Arithmetic Operators</h4>
        <p>
          Arithmetic operators are used to perform basic mathematical
          operations in Python, including addition, subtraction,
          multiplication, and division. Python supports all the binary
          arithmetic operators shown in the following table. A binary
          operator operates on exactly two elements, one on each side
          of the operator's symbol. When performing operations on
          integers, Python performs integer arithmetic unless one of
          the operands is a floating-point number. Python also
          provides unary operators for plus and minus. Any expression
          returning a single numeric value can be preceded either by a
          minus or plus sign.
        </p>
        <p>
          The precedence of Arithmetic Operators in Python is as
          follows:
          <ol>
            <li>P - Parentheses</li>
            <li>E - Exponentiation</li>
            <li>
              M - Multiplication (Multiplication and division have the
              same precedence)
            </li>
            <li>D - Division</li>
            <li>
              A - Addition (Addition and subtraction have the same
              precedence)
            </li>
            <li>S - Subtraction</li>
          </ol>
        </p>

        <h4>Comparison Operators</h4>
        <p>
          Comparison operators, also known as relational operators,
          are used in Python to compare values. They evaluate to
          either <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode> based on the specified
          condition. The comparison operators in Python are shown in
          the following table. In Python, comparison operators have
          lower precedence than arithmetic operators. All comparison
          operators have the same precedence order.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9b800fb6e4" />

        <h4>Logical Operators</h4>
        <p>
          Logical operators are used to perform logical operations
          such as "AND," "OR," and "NOT" in Python. They are typically
          used to combine conditional statements and create more
          complex conditions. The precedence of Logical Operators in
          Python is as follows:
          <ol>
            <li>Logical NOT</li>
            <li>Logical AND</li>
            <li>Logical OR</li>
          </ol>
          The following example illustrates how to use logical
          operators in Python.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/129d457075" />

        <h4>Bitwise Operators</h4>
        <p>
          Bitwise operators are used to operate on binary numbers and
          perform bit-by-bit operations. An overview over the bitwise
          operators in Python is shown in the following table.
        </p>
        <p>
          The precedence of Bitwise Operators in python is as follows:
          <ol>
            <li>Bitwise NOT</li>
            <li>Bitwise Shift</li>
            <li>Bitwise AND</li>
            <li>Bitwise XOR</li>
            <li>Bitwise OR</li>
          </ol>
        </p>
        <LazyIframe src="https://trinket.io/embed/python/63e371be96" />

        <h4>Identity and Membership Operators</h4>
        <p>
          In Python, identity and membership operators are essential
          for comparing and checking the relationships between values,
          variables, and sequences. The <InlineCode>is</InlineCode>{' '}
          operator is used to check if two values or variables refer
          to the same object in memory. It returns{' '}
          <InlineCode>True</InlineCode> if they do and
          <InlineCode>False</InlineCode> otherwise. It is not used to
          compare the values themselves, but rather their identity.
          The <InlineCode>is not</InlineCode> operator is the negation
          of is. It returns <InlineCode>True</InlineCode> if two
          values or variables do not refer to the same object and
          <InlineCode>False</InlineCode> if they do.
        </p>
        <p>
          The <InlineCode>in</InlineCode> operator is used to check if
          a value or variable is present in a sequence (e.g., a list,
          tuple, string, or set). It returns{' '}
          <InlineCode>True</InlineCode> if the value is found in the
          sequence and <InlineCode>False</InlineCode> otherwise. The
          <InlineCode>not in</InlineCode> operator is the negation of{' '}
          <InlineCode>in</InlineCode>.
        </p>
        <p>
          Python provides a concise way to evaluate an expression
          based on a condition using ternary operators. The basic
          syntax is{' '}
          <InlineCode>
            [on_true] if [expression] else [on_false]
          </InlineCode>
          . This allows you to write compact code instead of needing a
          multi-line if-else statement. Ternary operators are
          especially useful when you need to assign a value to a
          variable based on a condition in a single line.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/0ca3472fc8" />

        <h3 id="control-structures">Control Structures</h3>
        <h4>Conditions</h4>
        <p>
          In Python, control structures like the{' '}
          <InlineCode>if</InlineCode> statement, along with optional{' '}
          <InlineCode>elif</InlineCode> and{' '}
          <InlineCode>else</InlineCode> statements, are the foundation
          for executing conditional logic in your programs. The{' '}
          <InlineCode>if</InlineCode>
          statement evaluates the expression following it. If the
          expression is true, Python executes the statement(s) that
          follow. If the expression is false, Python continues with
          the <InlineCode>elif</InlineCode> statement (if there is
          one), and tests that expression. It proceeds to test the
          expressions associated with any{' '}
          <InlineCode>elif</InlineCode> statements in order, executing
          the first set of statements for which the expression is
          true. If none of the <InlineCode>elif</InlineCode>{' '}
          expressions are true, and there is an{' '}
          <InlineCode>else</InlineCode> statement, Python executes the
          statement(s) associated with the{' '}
          <InlineCode>else</InlineCode>. If there's no{' '}
          <InlineCode>else</InlineCode> statement, Python simply moves
          on to the statements following the{' '}
          <InlineCode>if</InlineCode> block. It's important to note
          that once Python encounters a true expression associated
          with an <InlineCode>if</InlineCode> or{' '}
          <InlineCode>elif</InlineCode> statement, it executes the
          corresponding statement(s) and doesn't evaluate any other
          expressions that follow.
        </p>
        <h4>Loops</h4>
        <p>
          Python provides two primary types of loops: the{' '}
          <InlineCode>for</InlineCode> loop and the{' '}
          <InlineCode>while</InlineCode> loop.
        </p>
        <p>
          Python, like other programming languages, provides a{' '}
          <InlineCode>for</InlineCode> loop which allows you to
          iterate. Although, the <InlineCode>for</InlineCode> loop is
          very useful, there is a more "pythonic" and powerful way for
          iteration in Python. The <InlineCode>for in</InlineCode>{' '}
          loop allows you to iterate over all the values in a sequence
          (e.g. string, list or tuple), performing the same task in
          each element. If the elements of the sequence being iterated
          over contain tuples or lists, a comma separated list can be
          used to unpack each individual element of the sequence. If
          you need an index, you can use{' '}
          <InlineCode>enumerate</InlineCode>.
        </p>
        <p>
          The <InlineCode>for</InlineCode> loop provides a great way
          to process the elements of a sequence. However, sometimes it
          is necessary to do some repetitive computation which is not
          based on an array. In those cases, the{' '}
          <InlineCode>while</InlineCode> loop can be used. When Python
          encounters a <InlineCode>while</InlineCode> loop, it firsts
          tests the expression provided. If the expression is false
          and there's an <InlineCode>else</InlineCode> clause, Python
          executes the statements following the{' '}
          <InlineCode>else</InlineCode>. Without an{' '}
          <InlineCode>else</InlineCode> clause, if the expression is
          false, control moves to the first statement after the{' '}
          <InlineCode>while</InlineCode> loop. If the expression is
          true, Python executes the statements following the{' '}
          <InlineCode>while</InlineCode> statement. Once those
          statements are completed, the expression is tested again,
          and the process repeats. As long as the expression remains
          true, Python continues executing the statements after the
          <InlineCode>while</InlineCode>. When the expression becomes
          false, the statements after the{' '}
          <InlineCode>else</InlineCode> (if present) are executed.
        </p>
        <p>
          It's worth mentioning that Python programmers often use{' '}
          <InlineCode>while</InlineCode> loops in a somewhat
          unconventional way. They may create "infinite" loops and
          control when to exit the loop with statements inside the
          loop. To exit a loop (<InlineCode>for</InlineCode> or{' '}
          <InlineCode>while</InlineCode>) prematurely, you can use the{' '}
          <InlineCode>break</InlineCode> statement. The{' '}
          <InlineCode>continue</InlineCode> statement, on the other
          hand, is used to skip the remaining part of the current
          iteration and move on to the next one. In a{' '}
          <InlineCode>for</InlineCode> loop, the loop variable's value
          is automatically incremented after a{' '}
          <InlineCode>continue</InlineCode> statement, so the next
          iteration proceeds as usual.
        </p>

        <h3 id="data-structures">Data Structures</h3>
        <p>...</p>

        <h4>Lists</h4>
        <p>
          Lists serve as a fundamental tool in Python for holding
          collections of objects that are indexed using numerical
          positions. These objects within a list can span various
          types, including numbers, strings, functions, user-defined
          objects, and even other lists. This versatility enables the
          creation of complex data structures with ease. To define a
          list in Python, enclose a sequence of elements you want
          within square brackets, separated by commas. To initialize
          an empty list, simply use square brackets without any
          elements inside. Notably, the items in a list can have
          different data types. Accessing individual elements within a
          list is achieved by employing square brackets after the
          list's name, specifying the index of the desired element.
          It's important to remember that Python employs zero-based
          indexing, meaning the first element corresponds to index 0.
          In the case of nested lists (lists within lists), you can
          utilize additional sets of square brackets to access
          individual elements. To get the number of elements within a
          list, Python offers the built-in{' '}
          <InlineCode>len()</InlineCode> function.
          <LazyIframe src="https://trinket.io/embed/python/179b14e949" />
        </p>
        <h5>List Indexing and Slicing</h5>
        <p>
          The slicing operations introduced in the section about
          strings are equally applicable to lists, with a particularly
          useful extension. In addition to utilizing slicing to
          extract a section of a list, you can employ slicing to
          assign values to elements within a list, indicated by a
          slice positioned on the left side of an equal sign. This
          distinction arises from the fact that lists are mutable
          objects, while strings are immutable. When assigning values
          using this approach, if the count of elements in the list on
          the right side of the assignment doesn't match the number of
          elements suggested by the slice's subscript, the list will
          automatically adjust its size to accommodate the assignment.
          Conversely, assignments performed via a single subscript
          will consistently maintain the list's length. Slices further
          offer the capability to remove elements from a list.
          Alternatively, the <InlineCode>del</InlineCode> statement
          can be employed to remove items from a list. To use the{' '}
          <InlineCode>del</InlineCode> statement, specify the element
          or slice of the list that requires deletion. Another
          important use of slices is to make a separate modifiable
          copy of a list. We will discuss later why this is important.
          In this case, a slice is created without a starting and
          ending index.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/1c6c2fe35d" />
        <h5>List Operators</h5>
        <h6>Concatenation</h6>
        <p>
          To merge the contents of two lists, the plus sign is used to
          concatenate them. The outcome is a unified list whose length
          equals the sum of both original lists' lengths. This new
          list contains all the elements from the first list followed
          by all the elements from the second list. List concatenation
          only works when combining two lists. To add a scalar to the
          end of a list, you either need to surround the scalar with
          square brackets or use the <InlineCode>append()</InlineCode>{' '}
          method.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ef8c8f064f" />
        <h6>Repetition</h6>
        <p>
          As for strings, the asterisk is overloaded for lists to
          serve as a repetition operator, Applying repetition to a
          list results in a single list with the elements of the
          original list repeated as many times as specified. A list
          consisting other lists can be created by surrounding a list
          to be repeated with an extra set of square brackets.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/74423edc47" />
        <h6>
          The <InlineCode>in</InlineCode> Operator
        </h6>
        <p>
          The <InlineCode>in</InlineCode> operator provides an
          extremely convenient technique for determining whether a
          specific value resides within a list. These evaluations are
          structured by positioning a value on the left side of the
          operator and a list on the right side. The outcome is either{' '}
          <InlineCode>True</InlineCode> or{' '}
          <InlineCode>False</InlineCode>, rendering it highly suitable
          for conditional statements. It's important to exercise
          caution when constructing expressions employing the{' '}
          <InlineCode>in</InlineCode> operator, as an exact match in
          both type and value is necessary for a{' '}
          <InlineCode>True</InlineCode> result. Moreover, the{' '}
          <InlineCode>in</InlineCode> operator works seamlessly with
          expressions that evaluate to elements within a list.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/be273e1259" />
        <h6>List Comprehension</h6>
        <p>
          List comprehensions are a concise and elegant way to create
          lists in Python. They allow you to generate a new list by
          applying an expression to each item in an existing iterable
          (like a list, tuple, or range) and optionally applying a
          condition to filter the items. List comprehensions not only
          make your code more compact, but they also enhance its
          readability by encapsulating complex operations in a
          comprehensible format.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/684e868e0f" />
        <h6>Functions and Methods for Lists</h6>
        <p>
          We already learnt that the <InlineCode>len()</InlineCode>{' '}
          function will return the number of elements in a list. But
          there are more built-in functions and methods for lists in
          Python. For a single list input, the{' '}
          <InlineCode>min()</InlineCode> function extracts the
          smallest element from the list, while the{' '}
          <InlineCode>max()</InlineCode> function retrieves the
          largest. To append a single element at the end of a list,
          the <InlineCode>append()</InlineCode> method can be used. If
          you need to add several elements to the end of a list,
          either the concatenation operator or the{' '}
          <InlineCode>extend()</InlineCode>method can be employed. If
          your intent is to insert an element at a position other than
          the end of the list, the <InlineCode>insert()</InlineCode>{' '}
          method proves useful. This method demands two arguments: the
          index for the insertion location and the item itself.
          Notably, a single element can be inserted using{' '}
          <InlineCode>insert()</InlineCode>, while for multiple
          insertions, slicing can be utilized. When the objective
          involves eliminating an item from a list based on its value,
          the <InlineCode>remove()</InlineCode> method proves
          invaluable. It removes only the initial occurrence of the
          value within the list. Both the{' '}
          <InlineCode>reverse()</InlineCode> and{' '}
          <InlineCode>sort()</InlineCode> methods operate in place,
          meaning they change the original order of elements within
          the list. If preservation of the initial order is essential,
          it's advisable to generate a copy of the list. By default,
          the <InlineCode>sort()</InlineCode> method sorts its numeric
          arguments in numerical order and string arguments in
          alphabetical order. Recall that lists can contain arbitrary
          objects, so <InlineCode>sort()</InlineCode> needs to be very
          flexible. In general, it sorts scalar numeric values before
          scalar string values and lists by first comparing their
          initial elements and continuing through the available list
          elements until one list differs from the other. The{' '}
          <InlineCode>count()</InlineCode> method accepts a single
          argument representing the value to be located and calculates
          the frequency of that value within the list. On the other
          hand, the <InlineCode>index()</InlineCode> method offers the
          index (subscript) of the first occurrence of a specified
          value.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/697878d467" />

        <h4>Tuples</h4>
        <p>
          Tuples, like lists, are a fundamental data structure in
          Python, used to store collections of items. They can contain
          elements of various data types, including numbers, strings,
          and even other tuples. Tuples are similar to lists but there
          is one important difference, namely that tuples are not
          mutable. This means that once a tuple is created, its
          elements can't be modified in place. The immutability of
          tuples makes them valuable in scenarios where you want to
          ensure that the data remains constant throughout the
          program's execution. Tuples are constructed by enclosing
          their values within parentheses. When a tuple is not
          embedded within an expression, the parentheses may be
          omitted. To create an empty tuple, simply utilize a pair of
          empty parentheses. However, due to the use of parentheses
          for grouping in arithmetic expressions, it is essential to
          include a comma after the sole element to explicitly denote
          a tuple with only one element in an assignment statement.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/9e85dc5f9b" />
        <h5>Operators and Indexing for Tuples</h5>
        <p>
          The same operators as mentioned in the previous section for
          lists apply to tuples. Keep in mind that tuples are
          immutable. Thus, slicing operations for tuples are more
          similar to strings than lists. Slicing can be used to
          extract parts of a tuple, but not to change it.
        </p>
        <h5>Functions and Methods for Tuples</h5>
        <p>
          There are no methods for tuples. However, tuples and list
          can be easily converted to each other using the built-in
          function <InlineCode>list</InlineCode> and{' '}
          <InlineCode>tuple</InlineCode>.
        </p>

        <h4>Dictionaries</h4>
        <p>
          Dictionaries in Python share similarities with lists, as
          they can store arbitrary objects and be nested to any
          desired depth. However, unlike lists, dictionaries are
          indexed by keys, which can be any immutable object, such as
          strings or tuples. Let's delve into this concept with a
          straightforward example: imagine a scenario where we want to
          store student matriculation numbers as tuples inside a list,
          where the first tuple element represents the student's name,
          and the second element is their matriculation number.
          However, if we wish to retrieve the matriculation number of
          a specific student, we'd need to search through each element
          in the list to find the tuple with the student's name as the
          first element before we can access the desired number. With
          a dictionary, we can use the student's name as the index,
          often referred to as a key. This significantly simplifies
          the process of retrieving the information we need:
        </p>
        <LazyIframe src="https://trinket.io/embed/python/2f654ae385" />
        <p>
          As the example above illustrates, a dictionary can be
          initialized using a comma-separated list of key/value pairs
          enclosed in curly braces. An empty dictionary can be created
          with a pair of empty curly braces. It's important to note
          that dictionary keys are not limited to strings, and they
          don't need to be of the same data type. However, it's
          crucial to remember that mutable objects, such as lists,
          cannot be used as dictionary keys. You can add key/value
          pairs to a dictionary using assignment statements, and if
          you need to remove a specific key/value pair from a
          dictionary, you can use the <InlineCode>del</InlineCode>{' '}
          statement for this purpose.
        </p>
        <h5>Functions and Methods for Dictionaries</h5>
        <p>TODO</p>

        <h4>Sets</h4>
        <p>
          Python's built-in set type is similar to dictionaries. Sets
          are unordered and its elements are unique. A set itself can
          be modified, but the elements in the set must be immutable.
          There are two ways to create a set in Python: first, you can
          create a set using the built-in{' '}
          <InlineCode>set()</InlineCode> function or alternately, a
          set can be defined using curly braces. To define an empty
          set, the <InlineCode>set()</InlineCode> function needs to be
          used. Recall that Python interprets empty curly braces as an
          empty dictionary. The elements in a set can be objects of
          different types. However, keep in mind that set elements
          must be immutable. Thus, a tuple may be included in a set,
          but lists and dictionaries are mutable, so they can't be set
          elements.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/3f3742ad5d" />
        <h5>Functions and Methods for Sets</h5>
        <p>
          As for lists, the <InlineCode>len()</InlineCode> function
          can be used to get the number of elements in a set and the{' '}
          <InlineCode>in</InlineCode> and{' '}
          <InlineCode>not in</InlineCode> operators can be used to
          test for membership. However, many of the operations that
          can be used for Python's other data types, don't make sense
          for sets. For example, sets can't be indexed or sliced.
          Nevertheless, Python provides a bunch of operation on set
          objects which are similar to the operations defined for
          mathematical sets. Set union of two or more sets can be
          performed with the "|" operator or with the{' '}
          <InlineCode>union()</InlineCode> method. The resulting set
          contains all elements that are present in any of the
          specified sets. To compute the intersection of two or more
          sets , i.e. return a set containing only elements that are
          present in all of the specified sets, the "&" operator or{' '}
          <InlineCode>intersection()</InlineCode> method can be used.
          The difference between two or more sets can be computed
          using the "-" operator or the{' '}
          <InlineCode>difference()</InlineCode> method. For two sets,
          this will return a set containing all elements that are in
          the first set, but not in the second set. When multiple sets
          are specified, the operation is performed from left to
          right. There are many more operations available such as{' '}
          <InlineCode>update()</InlineCode> for updating a set,{' '}
          <InlineCode>add()</InlineCode> to add an element to a set,{' '}
          <InlineCode>remove()</InlineCode> to remove an element from
          a set and <InlineCode>clear()</InlineCode> to remove all
          elements from a set. For more details, refer to the{' '}
          <ExternalLink href="https://docs.python.org/3.11/library/stdtypes.html#set">
            Python documentation
          </ExternalLink>{' '}
          .There's also another built-in type in Python called{' '}
          <InlineCode>frozenset</InlineCode> which is exactly the same
          as set, but is immutable.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/ab8ea2aa12" />

        <h3 id="functions-and-modules">Functions and Modules</h3>

        <h4>Functions</h4>
        {/* TODO: Sandbox examples */}
        <p>
          Functions are a fundamental component of any programming
          language for two primary reasons. First, they enable code
          reusability, eliminating the need to duplicate and modify
          code each time it's used. Second, functions allow you to
          logically isolate various sub-tasks that inevitably arise
          when working on a program. This programming approach is
          known as modular programming and is generally considered a
          best practice for writing readable and maintainable code.
        </p>
        <p>
          In Python, functions are treated as objects. As a result,
          they can be assigned to variables, stored in lists or
          tuples, passed as arguments to other functions, and more.
          However, functions possess a unique property that
          distinguishes them from other Python objects: they can
          accept a list of arguments enclosed in parentheses and
          optionally return a value. You may already be familiar with
          some of Python's built-in functions, such as{' '}
          <InlineCode>len()</InlineCode>, and you've encountered
          methods, which are similar to functions and defined in a
          similar manner. In this section, we will delve into various
          aspects of functions, including how to create and import
          them into your programs.
        </p>
        <h5>Variable Scoping</h5>
        <p>
          In Python, you can typically reference variables anywhere in
          your program. However, when you define a function, Python
          creates a distinct namespace within that function. A
          namespace serves as a mapping between object names in your
          program and their corresponding memory locations where
          Python stores their values. Consequently, when a variable is
          created inside a function, Python recognizes it as a local
          variable within that function's namespace, distinct from
          variables with the same name defined elsewhere in the
          program. You can also reference a variable inside a function
          that already exists in your program at the time the function
          is called. Additionally, you can declare global variables
          using the <InlineCode>global</InlineCode> statement, though
          this should be only used for situations where no other
          reasonable solution is available. Consequently, we won't
          delve into global variables in detail here. When Python
          attempts to resolve the reference of a name in your program,
          names within a function's local namespace take precedence,
          followed by names of global objects or objects imported into
          the global namespace from a module. Finally, built-in object
          names are searched as a last resort. Due to this search
          order, Python's scoping is sometimes referred to as
          following the LGB rule.
        </p>
        <h5>Function Basics</h5>
        <p>
          In Python, functions are defined using the{' '}
          <InlineCode>def</InlineCode> statement. The function's name
          follows the <InlineCode>def</InlineCode> keyword, followed
          by a parenthesized list of arguments to be passed to the
          function. If a function does not require any arguments, an
          empty set of parentheses is used. A colon (:) comes after
          the parenthesized list. On the next line, an indented
          triple-quoted string, known as a docstring, provides
          documentation about the function. While not strictly
          necessary, docstrings are good practice. The function body
          follows the <InlineCode>def</InlineCode> line and the
          optional docstring. The function returns control to the
          calling environment when it encounters a{' '}
          <InlineCode>return</InlineCode> statement or when it reaches
          the end of the function body. If the function lacks a{' '}
          <InlineCode>return</InlineCode> statement, calling it will
          return the value <InlineCode>None</InlineCode>. To call a
          function, you refer to its name followed by a parenthesized
          list of arguments. For functions with no arguments, you
          simply use empty parentheses.
        </p>
        <h5>Name Arguments and Default Values</h5>
        <p>
          When passing arguments to a function without specifying
          their names, Python assumes that you've arranged the
          arguments in the order they were defined in the function. To
          mitigate the need to remember argument order, Python allows
          you to use named arguments. When calling a function, you can
          precede some or all of the arguments with a name and an
          equal sign, making it clear which argument corresponds to
          which parameter in the function. For added flexibility, when
          defining a function, Python allows you to specify default
          values for some or all of the arguments, making it optional
          for users to provide these arguments. To set a default value
          when defining a function, use a syntax similar to naming
          arguments when calling a function, appending an equal sign
          followed by the desired default value. When combining named
          and unnamed arguments in a function call, unnamed arguments
          must precede named ones in the argument list. Thus, place
          required arguments before optional ones in the function's
          argument list.
        </p>
        <h5>Variable Number of Arguments</h5>
        <p>
          In some cases, it's impossible to predict in advance how
          many arguments a function will receive. By designating a
          function argument with a name beginning with an asterisk,
          Python will collect all unnamed arguments passed to the
          function into a tuple, which can be accessed using that
          argument's name. A similar technique can be employed to
          create functions that can handle an unlimited number of
          keyword-argument pairs. If an argument in a function is
          prefixed with two asterisks, Python will collect all
          keyword-argument pairs that were not explicitly declared as
          arguments into a dictionary. This argument must be the last
          one in the function definition. This approach enables you to
          write a function that accepts any named parameter, even if
          you don't know the parameter name when writing the function.
        </p>
        <h5>Functional Programming and Anonymous Functions</h5>
        <p>
          When you need to perform the same operation on a list of
          objects, an alternative to using a{' '}
          <InlineCode>for</InlineCode> loop is the{' '}
          <InlineCode>map</InlineCode> function. This function accepts
          another function as its first argument and one or more lists
          as additional arguments. The number of provided lists must
          match the number of arguments expected by the mapped
          function. Python offers the <InlineCode>lambda</InlineCode>{' '}
          operator for creating anonymous functions when you only need
          a function once. Anonymous functions are limited to a single
          statement, which becomes the value returned by the{' '}
          <InlineCode>lambda</InlineCode> operator. Instead of
          enclosing the arguments in parentheses, you list them after
          the <InlineCode>lambda</InlineCode> keyword, separated by
          commas.
        </p>
        <p>
          Another functional programming tool in Python is the{' '}
          <InlineCode>filter</InlineCode> function. Like{' '}
          <InlineCode>map</InlineCode>, it takes a function as its
          first argument and a list as its second argument. However,{' '}
          <InlineCode>filter</InlineCode> returns a new list
          containing only those elements for which the function
          returns <InlineCode>True</InlineCode>. You might also recall
          list comprehensions as an alternative way to apply an
          expression to all elements of a list. In fact, a list
          comprehension with a single <InlineCode>for</InlineCode>{' '}
          clause is similar to a call to <InlineCode>map</InlineCode>.
          By adding an <InlineCode>if</InlineCode> clause to the
          comprehension, it becomes similar to embedding a call to{' '}
          <InlineCode>filter</InlineCode> within a{' '}
          <InlineCode>map</InlineCode>.
        </p>
        <p>
          Finally, the <InlineCode>reduce</InlineCode> function takes
          a function with exactly two arguments as its first argument
          and a list as its second argument. It successively applies
          the function to the list's elements, using the current
          result as the first argument and an element from the list as
          the second argument. <InlineCode>reduce</InlineCode> returns
          a scalar value. Optionally, you can provide a third argument
          as a starting value, which defaults to 0.
        </p>

        <h4>Modules</h4>
        <p>
          Python's core design philosophy emphasizes simplicity and
          efficiency, keeping the language small and easy to learn.
          However, many programming tasks require additional
          capabilities, which are provided through the use of modules.
          In Python, a module is a collection of code that groups
          together functions, classes, and variables according to
          functionality. Modules serve as a way to organize your code
          into reusable and logically grouped components. They are
          essential for managing complexity in larger programs and
          promoting code reuse across projects. Python comes with an
          extensive standard library of modules that provide pre-built
          functionality for various tasks. We will explore some of the
          most commonly used standard modules distributed with Python
          later on. In addition to the standard modules, there are
          many additional packages available for installation, such as
          those from PyPi or Conda. However, exercise caution when
          installing third-party packages to ensure their
          trustworthiness and compatibility with your project.
        </p>
        <p>
          To create a module, you simply save your Python code in a
          separate <InlineCode>.py</InlineCode> file with a
          descriptive name, such as{' '}
          <InlineCode>my_module.py</InlineCode>. This file should
          contain functions, classes, or variables that you want to
          reuse in other parts of your program or in other programs.
          As discussed earlier in the context of variable scoping,
          Python identifies which variable or function you are
          referring to by resolving its name in a namespace. To use
          functions, classes, or variables from a module in your
          Python program, you need to import the module. Python
          provides three ways to do this. The simplest way to access a
          module is to provide the module's name to the{' '}
          <InlineCode>import</InlineCode> statement. For example, to
          import a module named <InlineCode>my_module</InlineCode>,
          you'd use <InlineCode>import my_module</InlineCode>. It
          makes all the functions, classes, and variables in the
          module available under the{' '}
          <InlineCode>my_module</InlineCode> namespace. If you only
          need specific items from a module, you can import them
          directly. This way, you can use{' '}
          <InlineCode>function_name</InlineCode> without needing to
          prefix it with <InlineCode>module_name</InlineCode>. For
          instance,{' '}
          <InlineCode>from my_module import my_function</InlineCode>.
          While this approach is slightly more efficient than
          importing an entire module, it eliminates the explicit
          connection between the imported function and the module it
          was imported from. You also need to list every function you
          want to use in the import statement. You can also import all
          of the objects from a module into the local namespace by
          using an asterisk after the <InlineCode>import</InlineCode>{' '}
          statement, e.g.{' '}
          <InlineCode>from my_module import *</InlineCode>. Since this
          may override existing objects and even built-in objects,
          imports of whole modules should be used carefully. To give a
          module a shorter name, you can use the{' '}
          <InlineCode>as</InlineCode> keyword to create an alias. This
          is useful when working with modules with long names or to
          avoid naming conflicts. For example,{' '}
          <InlineCode>import my_long_module_name as mlm</InlineCode>.
        </p>
        <p>
          When you import a module, Python searches for it in a
          specific order. First, it checks the current directory where
          your script is located. Then, it looks in the built-in
          modules. Finally, it searches in directories listed in the
          <InlineCode>sys.path</InlineCode> variable. Understanding
          this order can help you manage your module imports
          effectively.
        </p>
        <p>
          When the Python interpreter reads a source file, it executes
          all the code found in that file. Consequently, when you
          <InlineCode>import</InlineCode> a module into a Python
          program, the contents of the module are executed. This
          behavior can lead to unintended consequences when users
          accidentally invoke scripts they didn't intend to. To
          address this issue, Python provides a built-in variable
          called <InlineCode>__name__</InlineCode>. This variable has
          a special role in module execution. When a module is
          imported, the <InlineCode>__name__</InlineCode> variable is
          set to the name of that module. However, when a program is
          executed directly (as opposed to being imported as a
          module), the <InlineCode>__name__</InlineCode> variable is
          set to the value
          <InlineCode>"__main__"</InlineCode>. This concept forms the
          basis for the commonly seen{' '}
          <InlineCode>if __name__ == "__main__":</InlineCode>{' '}
          statement in Python code. It allows you to differentiate
          between code that should run only when the script is
          executed directly and code that should be available for
          import as a module. By using the{' '}
          <InlineCode>if __name__ == "__main__":</InlineCode>{' '}
          construct, you can conditionally execute specific code
          blocks only when the script is run directly. This is
          particularly useful for creating reusable modules that can
          be both imported and executed independently.
        </p>

        <h3 id="object-oriented-programming">
          Object-Oriented Programming
        </h3>
        <p>
          Object-Oriented Programming (OOP) is a programming paradigm
          that uses objects and classes to structure code. In Python,
          everything is an object, and classes are the blueprints for
          creating objects. A class defines the attributes (data) and
          methods (functions) that objects of that class will have.
          OOP promotes the organization of code into reusable,
          self-contained units, making it easier to manage and
          maintain complex systems.
        </p>
        <p>
          In Python, you define a class using the{' '}
          <InlineCode>class</InlineCode> keyword followed by the class
          name. The class definition typically contains attributes and
          methods. Attributes are variables that store data, while
          methods are functions that define the behaviors of the
          objects created from the class. To use a class, you create
          objects or instances of that class. This process is known as
          instantiation. Each object is a unique instance of the
          class, with its own set of attributes and the ability to
          call methods defined in the class.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/428a5eedae" />
        <p>
          In Python, the <InlineCode>self</InlineCode> parameter is a
          reference to the instance of the class. It is the first
          parameter in all instance methods and allows you to access
          and modify attributes and call other methods within the
          class. While you can name this parameter differently, it's a
          convention to use <InlineCode>self</InlineCode>.
        </p>
        <h4>Operator Overloading</h4>
        <p>
          Besides creating methods on our own, we can change the way
          many familiar operators work by a technique known as
          operator overloading. Special methods, whose names begin and
          end with double underscores, can be defined to intercept
          many common operators, allowing you to redefine what such
          operators as <InlineCode>print</InlineCode>,{' '}
          <InlineCode>+</InlineCode>, and <InlineCode>*</InlineCode>,
          or functions like <InlineCode>len</InlineCode>, will do when
          they're applied to the objects you create. One of the most
          important operator overloading methods is the{' '}
          <InlineCode>__init__</InlineCode> method.
        </p>
        <p>
          The <InlineCode>__init__</InlineCode> method is a special
          method in Python classes, also known as the constructor. It
          gets called when you create a new instance of the class and
          allows you to initialize attributes.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/645f08ebd4" />
        <p>
          The <InlineCode>__str__</InlineCode> method is called
          through the print statement. The{' '}
          <InlineCode>__repr__</InlineCode> method is called when an
          object's name is typed in the interpreter. The following
          table lists some of the more commonly used methods for
          overloading.
        </p>
        <p>
          In addition, you can define what happens when your object is
          iterated over by means of the for statement by defining an
          <InlineCode>__iter__</InlineCode> method that simply returns
          the object itself and providing a{' '}
          <InlineCode>next</InlineCode> method which will be called
          for each iteration. Inside the <InlineCode>next</InlineCode>{' '}
          method, you need to raise a{' '}
          <InlineCode>StopIteration</InlineCode> exception when no
          more items are available.
        </p>

        <h4>Private Attributes</h4>
        <p>
          In many object-oriented languages, certain attributes can be
          declared as private, making it impossible for users of a
          class to directly view or modify their values. The designer
          of the class then provides methods to control the ways in
          which these attributes can be manipulated. While Python
          classes don't have true private attributes, if an attribute
          name begins with two underscores, the Python interpreter
          internally modifies the attribute's name, so that references
          to the attribute will not be resolved. The attribute name is
          still accessible, but this convention indicates that an
          attribute should not directly be manipulated and gives you
          more control over the way users of your class will
          manipulate those attributes.
        </p>

        <h4>Class and Instance Variables</h4>
        <p>
          Class variables are shared by all instances of a class and
          are defined within the class but outside any method.
          Instance variables are specific to each instance of a class
          and are typically defined within the{' '}
          <InlineCode>__init__</InlineCode> method.
        </p>

        <h4>Class Methods and Static Methods</h4>
        <p>
          Class methods are methods that are bound to the class and
          not the instance. They can access and modify class-level
          attributes. Static methods are similar but don't have access
          to instance-specific or class-specific attributes.
        </p>

        <h4>Inheritance</h4>
        <p>
          Inheritance is a fundamental concept in OOP that allows you
          to create new classes based on existing ones. The new class
          (subclass or derived class) inherits attributes and methods
          from the parent class (base class or superclass). You can
          also override or extend inherited methods and attributes in
          the subclass.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/4bc092e290" />

        <h4>Encapsulation</h4>
        <p>
          Encapsulation is the practice of bundling data (attributes)
          and the methods (functions) that operate on that data into a
          single unit (a class). It helps hide the internal details of
          how an object works, providing an interface for interacting
          with the object while protecting its integrity.
        </p>
        <LazyIframe src="https://trinket.io/embed/python/f6c4270aab" />

        <h4>Polymorphism</h4>
        <p>
          Polymorphism is the ability of different objects to respond
          to the same method or attribute in a way that is appropriate
          for their individual types. Python supports polymorphism
          through method overriding and method overloading. The
          example provided for inheritance also demonstrates
          polymorphism since the subclasses "Cat" and "Dog" override
          the <InlineCode>speak</InlineCode> method of the "Animal"
          base class.
        </p>

        <h3 id="debugging-error-handling-and-unit-testing">
          Debugging, Error Handling and Unit Testing
        </h3>
        <p></p>

        <h3>Standard Library</h3>
        <p>Follows soon...</p>

        <h3>Misc</h3>
        <p>Follows soon...stay tuned!</p>
      </Article>
    </main>
  );
};

export { IntroductionToPython };
